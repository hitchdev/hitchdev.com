<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Strictyamls on HitchDev</title>
    <link>https://hitchdev.com/strictyaml/</link>
    <description>Recent content in Strictyamls on HitchDev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (C) 2018</copyright>
    
	<atom:link href="https://hitchdev.com/strictyaml/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hitchdev.com/strictyaml/changelog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/changelog/</guid>
      <description>Changelog Latest No relevant code changes.
0.15.2  BUGFIX : Modifying YAML via getitem where the YAML was validated using an OR operator failed - or validators didn&amp;rsquo;t have a key_validator.  0.15.1  BUGFIX : Make optional values parsed using Optional appear at the end of the ordered dict. BUGFIX : Prevent YAML objects from appearing in .data. BUGFIX : Fix for bug caused by revalidation with Optional default values.</description>
    </item>
    
    <item>
      <title>Boolean (Bool)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/boolean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/boolean/</guid>
      <description>Boolean values can be parsed using a Bool validator.
It case-insensitively interprets &amp;ldquo;yes&amp;rdquo;, &amp;ldquo;true&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;on&amp;rdquo; as &amp;ldquo;True&amp;rdquo;, &amp;ldquo;y&amp;rdquo; and their opposites as False.
Different values will trigger a validation error.
When updating boolean values on a YAML object with True or False, the roundtripped string version is set to &amp;ldquo;yes&amp;rdquo; and &amp;ldquo;no&amp;rdquo;.
To have your boolean values updated to a different yes/no string, update with a string instead - e.</description>
    </item>
    
    <item>
      <title>Build a YAML document from scratch in code</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/build-yaml-document/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/build-yaml-document/</guid>
      <description>YAML documents can be built from combinations of dicts, lists and strings if no schema is used.
from ensure import Ensure from strictyaml import as_document from collections import OrderedDict # Can also use regular dict if an arbitrary ordering is ok yaml = as_document(OrderedDict( [(u&amp;#34;â&amp;#34;, &amp;#39;yes&amp;#39;), (&amp;#34;b&amp;#34;, &amp;#34;hâllo&amp;#34;), (&amp;#34;c&amp;#34;, [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;])] )) Then dump:
print(yaml.as_yaml())â:yesb:hâlloc:-1-2-3 However, any type that is not a string, dict or list cannot be parsed without a schema:</description>
    </item>
    
    <item>
      <title>Compound StrictYAML Validators</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/</guid>
      <description> Using a YAML object of a parsed mapping Sequence/list validator (Seq) Sequences of unique items (UniqueSeq) Mapping with defined keys and a custom key validator (Map) Fixed length sequences (FixedSeq) Mappings with arbitrary key names (MapPattern) Optional keys with defaults (Map/Optional) Mappings with defined keys (Map) Validating optional keys in mappings (Map)  </description>
    </item>
    
    <item>
      <title>Datetimes (Datetime)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/datetime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/datetime/</guid>
      <description>Datetime validator parses using the python-dateutil library and returns a python datetime object.
Example yaml_snippet:
date:2016-10-22datetime1:2016-10-22T14:23:12+00:00datetime2:2016-10-22T14:23:12Zdatetime3:20161022T142312Zfrom strictyaml import Map, Datetime, YAMLValidationError, load, as_document from collections import OrderedDict from dateutil.tz.tz import tzutc from datetime import datetime from ensure import Ensure schema = Map({ &amp;#34;date&amp;#34;: Datetime(), &amp;#34;datetime1&amp;#34;: Datetime(), &amp;#34;datetime2&amp;#34;: Datetime(), &amp;#34;datetime3&amp;#34;: Datetime(), }) equivalent_data = OrderedDict([ (&amp;#34;date&amp;#34;, datetime(2016, 10, 22, 0, 0)), (&amp;#34;datetime1&amp;#34;, datetime(2016, 10, 22, 14, 23, 12, tzinfo=tzutc())), (&amp;#34;datetime2&amp;#34;, datetime(2016, 10, 22, 14, 23, 12, tzinfo=tzutc())), (&amp;#34;datetime3&amp;#34;, datetime(2016, 10, 22, 14, 23, 12, tzinfo=tzutc())), ]) Each of the four datetimes are valid and parsed:</description>
    </item>
    
    <item>
      <title>Decimal numbers (Decimal)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/decimal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/decimal/</guid>
      <description>StrictYAML parses to a YAML object representing a decimal, not the value directly to give you more flexibility and control over what you can do with the YAML.
This is what that can object can do - in many cases if parsed as a decimal, it will behave in the same way.
To get a python decimal.Decimal object, use .data.
Parsing and validating as a Decimal is best for values which require precision, like prices.</description>
    </item>
    
    <item>
      <title>Design Justifications</title>
      <link>https://hitchdev.com/strictyaml/why/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/</guid>
      <description>StrictYAML is the result of some carefully considered, although controversial design decisions. These are justified here.
 What is wrong with explicit tags? What is wrong with explicit syntax typing in a readable configuration language? The Norway Problem - why StrictYAML won&amp;rsquo;t do implicit typing What is wrong with flow style YAML? Why does StrictYAML only parse from strings and not files? What is wrong with duplicate keys? Why is parsing speed not a high priority for StrictYAML?</description>
    </item>
    
    <item>
      <title>Dirty load</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/loading-dirty-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/loading-dirty-yaml/</guid>
      <description>StrictYAML refuses to parse flow style and node anchors by default, but since there have since been some requests to parse flow style, this now allowed with the &amp;ldquo;dirty_load&amp;rdquo; method.
from strictyaml import Map, Int, MapPattern, Seq, Str, Any, dirty_load schema = Map({&amp;#34;x&amp;#34;: Map({&amp;#34;a&amp;#34;: Any(), &amp;#34;b&amp;#34;: Any(), &amp;#34;c&amp;#34;: Any()}), &amp;#34;y&amp;#34;: MapPattern(Str(), Str()), &amp;#34;z&amp;#34;: Seq(Str())}) Flow style mapping:
x:{a:1,b:2,c:3}y:{}z:[]assert dirty_load(yaml_snippet, schema, allow_flow_style=True) == {&amp;#34;x&amp;#34;: {&amp;#34;a&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;2&amp;#34;, &amp;#34;c&amp;#34;: &amp;#34;3&amp;#34;}, &amp;#34;y&amp;#34;: {}, &amp;#34;z&amp;#34;: []} Executable specification</description>
    </item>
    
    <item>
      <title>Disallowed YAML</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/disallowed-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/disallowed-yaml/</guid>
      <description>StrictYAML parses an opinionated subset of the YAML specification which refuses to parse features which are otherwise valid in standard YAML.
For an explanation as to why these features are stripped out of StrictYAML, see the FAQ.
Disallowed YAML features raise Disallowed exceptions while syntactically invalid YAML raises ScannerError or ComposerError.
Every error inherits from YAMLError.
from strictyaml import Map, Int, Any, load from strictyaml import TagTokenDisallowed, FlowMappingDisallowed, AnchorTokenDisallowed schema = Map({&amp;#34;x&amp;#34;: Map({&amp;#34;a&amp;#34;: Any(), &amp;#34;b&amp;#34;: Any(), &amp;#34;c&amp;#34;: Any()})}) Tag tokens:</description>
    </item>
    
    <item>
      <title>Duplicate keys</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/duplicate-keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/duplicate-keys/</guid>
      <description>Duplicate keys are allowed in regular YAML - as parsed by pyyaml, ruamel.yaml and poyo:
Not only is it unclear whether x should be &amp;ldquo;cow&amp;rdquo; or &amp;ldquo;bull&amp;rdquo; (the parser will decide &amp;lsquo;bull&amp;rsquo;, but did you know that?), if there are 200 lines between x: cow and x: bull, a user might very likely change the first x and erroneously believe that the resulting value of x has been changed - when it has not.</description>
    </item>
    
    <item>
      <title>Either/or schema validation of different, equally valid different kinds of YAML</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/either-or-validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/either-or-validation/</guid>
      <description>StrictYAML can be directed to parse two different elements or blocks of YAML.
If the first thing does not parse correctly, it attempts to parse the second. If the second does not parse correctly, it raises an exception.
from strictyaml import Map, Bool, Int, Str, YAMLValidationError, load from ensure import Ensure schema = Str() | Map({&amp;#34;a&amp;#34;: Bool() | Int()}) Boolean first choice true:
a:yesEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: True}) Boolean first choice false:</description>
    </item>
    
    <item>
      <title>Email and URL validators</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/email-and-url/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/email-and-url/</guid>
      <description>StrictYAML can validate emails (using a simplified regex) and URLs.
from strictyaml import Email, Url, Map, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Email(), &amp;#34;b&amp;#34;: Url()}) Parsed:
a:billg@microsoft.comb:http://www.google.com/Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;billg@microsoft.com&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;http://www.google.com/&amp;#34;}) Exception:
a:notanemailb:notaurlload(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: when expecting an email address found non-matching string in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: notanemail ^ (line: 1) Executable specification
Page automatically generated from email-url.story.
 </description>
    </item>
    
    <item>
      <title>Empty key validation</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/empty/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/empty/</guid>
      <description>Sometimes you may wish to not specify a value or specify that it does not exist.
Using StrictYAML you can accept this as a valid value and have it parsed to one of three things - None, {} (empty dict), or [] (empty list).
Example yaml_snippet:
a:from strictyaml import Map, Str, Enum, EmptyNone, EmptyDict, EmptyList, load, as_document from ensure import Ensure EmptyNone with empty value:
Ensure(load(yaml_snippet, Map({&amp;#34;a&amp;#34;: EmptyNone() | Enum([&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;,])}))).</description>
    </item>
    
    <item>
      <title>Enumerated scalars (Enum)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/enum/</guid>
      <description>StrictYAML allows you to ensure that a scalar value can only be one of a set number of items.
It will throw an exception if any strings not in the list are found.
from strictyaml import Map, Enum, MapPattern, YAMLValidationError, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Enum([&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;])}) Valid because it contains &amp;lsquo;A&amp;rsquo;:
a:AEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;A&amp;#34;}) Valid because it contains &amp;lsquo;B&amp;rsquo;:
a:BEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;B&amp;#34;}) Valid because it contains &amp;lsquo;C&amp;rsquo;:</description>
    </item>
    
    <item>
      <title>Fixed length sequences (FixedSeq)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/fixed-length-sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/fixed-length-sequences/</guid>
      <description>Sequences of fixed length can be validated with a series of different (or the same) types.
from strictyaml import FixedSeq, Str, Map, Int, Float, YAMLValidationError, load from ensure import Ensure schema = FixedSeq([Int(), Map({&amp;#34;x&amp;#34;: Str()}), Float()]) Equivalent list:
-1-x:5-2.5Ensure(load(yaml_snippet, schema)).equals([1, {&amp;#34;x&amp;#34;: &amp;#34;5&amp;#34;}, 2.5, ]) Invalid list 1:
a:1b:2c:3load(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: when expecting a sequence of 3 elements in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: &amp;#39;1&amp;#39; ^ (line: 1) found a mapping in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 3, column 1: c: &amp;#39;3&amp;#39; ^ (line: 3) Invalid list 2:</description>
    </item>
    
    <item>
      <title>Floating point numbers (Float)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/float/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/float/</guid>
      <description>StrictYAML parses to a YAML object representing a decimal - e.g. YAML(1.0000000000000001)
To get a python float literal, use .data.
Parsing and validating as a Decimal is best for values which require precision, but float is better for values for which precision is not required.
Example yaml_snippet:
a:1.00000000000000000001b:5.4135from strictyaml import Map, Float, load, as_document from collections import OrderedDict from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Float(), &amp;#34;b&amp;#34;: Float()}) Use .data to get float type:</description>
    </item>
    
    <item>
      <title>Get line numbers of YAML elements</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/what-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/what-line/</guid>
      <description>Line numbers, the text of an item and text of surrounding lines can be grabbed from returned YAML objects - using .start_line, .end_line, lines(), lines_before(x) and lines_after(x).
Example yaml_snippet:
y:p# Some commenta:| x# Another commentb:yc:ad:bfrom strictyaml import Map, Str, YAMLValidationError, load from ensure import Ensure schema = Map({&amp;#34;y&amp;#34;: Str(), &amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Str(), &amp;#34;c&amp;#34;: Str(), &amp;#34;d&amp;#34;: Str()}) snippet = load(yaml_snippet, schema) If there is preceding comment for an item the start line includes it:</description>
    </item>
    
    <item>
      <title>How to...</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/</guid>
      <description> Get line numbers of YAML elements Revalidate an already validated document Build a YAML document from scratch in code Reading in YAML, editing it and writing it back out Labeling exceptions Merge YAML documents Either/or schema validation of different, equally valid different kinds of YAML Parsing YAML without a schema  </description>
    </item>
    
    <item>
      <title>Integers (Int)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/integer/</guid>
      <description>StrictYAML parses to a YAML object, not the value directly to give you more flexibility and control over what you can do with the YAML.
This is what that can object can do - in many cases if parsed as a integer, it will behave in the same way.
Example yaml_snippet:
a:1b:5from strictyaml import Map, Int, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Int(), &amp;#34;b&amp;#34;: Int()}) parsed = load(yaml_snippet, schema) Parsed correctly:</description>
    </item>
    
    <item>
      <title>Labeling exceptions</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/label-exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/label-exceptions/</guid>
      <description>When raising exceptions, you can add a label that will replace with whatever you want.
Example yaml_snippet:
a:1b:-1-2from strictyaml import Map, Int, load, YAMLValidationError Label myfilename:
load(yaml_snippet, Map({&amp;#34;a&amp;#34;: Int(), &amp;#34;b&amp;#34;: Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()})}), label=&amp;#34;myfilename&amp;#34;)strictyaml.exceptions.YAMLValidationError: when expecting a mapping in &amp;#34;myfilename&amp;#34;, line 2, column 1: b: ^ (line: 2) found a sequence in &amp;#34;myfilename&amp;#34;, line 4, column 1: - &amp;#39;2&amp;#39; ^ (line: 4) Executable specification
Page automatically generated from handle-exceptions.story.</description>
    </item>
    
    <item>
      <title>Mapping with defined keys and a custom key validator (Map)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-with-slug-keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-with-slug-keys/</guid>
      <description>Experimental
This feature is in alpha. The API may change on a minor version increment.
 A typical mapping except that the key values are determined by the value provided by the validator.
Example yaml_snippet:
Name:UnitedKingdomcountry-code:GBDIALCODE:+44officiallanguages:-English-Welshfrom collections import OrderedDict from strictyaml import Map, Optional, Str, Seq, load, ScalarValidator from ensure import Ensure # This example uses slugify from the &amp;#34;python-slugify&amp;#34; package from slugify import slugify class Slug(ScalarValidator): def validate_scalar(self, chunk): return slugify(unicode(chunk.</description>
    </item>
    
    <item>
      <title>Mappings with arbitrary key names (MapPattern)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/map-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/map-pattern/</guid>
      <description>When you do not wish to let the user define the key names in a mapping and and only specify what type the keys are, use a MapPattern.
When you wish to specify the exact key name, use the &amp;lsquo;Map&amp;rsquo; validator instead.
from strictyaml import MapPattern, Int, Str, YAMLValidationError, load from ensure import Ensure schema = MapPattern(Str(), Int()) Equivalence 1:
â:1b:2Ensure(load(yaml_snippet, schema)).equals({u&amp;#34;â&amp;#34;: 1, &amp;#34;b&amp;#34;: 2}) Equivalence 2:
a:1c:3Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1, &amp;#34;c&amp;#34;: 3}) Equivalence 3:</description>
    </item>
    
    <item>
      <title>Mappings with defined keys (Map)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/mapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/mapping/</guid>
      <description>Mappings of one value to another are represented by : in YAML and parsed as python dicts.
Using StrictYAML&amp;rsquo;s &amp;lsquo;Map&amp;rsquo; you can validate that a mapping contains the right keys and the right type of values.
Note: for mappings where you don&amp;rsquo;t know the exact names of the keys in advance but you do know the type, use MapPattern.
Example yaml_snippet:
â:1b:2c:3from collections import OrderedDict from strictyaml import Map, Int, load, as_document from collections import OrderedDict from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Int(), &amp;#34;b&amp;#34;: Int(), &amp;#34;c&amp;#34;: Int()}) schema_2 = Map({u&amp;#34;â&amp;#34;: Int(), &amp;#34;b&amp;#34;: Int(), &amp;#34;c&amp;#34;: Int()}) one key mapping:</description>
    </item>
    
    <item>
      <title>Merge YAML documents</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/merge-yaml-documents/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/merge-yaml-documents/</guid>
      <description>Loaded YAML can be combined and dumped with the comments intact.
from strictyaml import Map, MapPattern, Str, Seq, Int, load schema_1 = Map({ &amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()}), &amp;#34;c&amp;#34;: Seq(MapPattern(Str(), Str())), }) schema_2 = Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()}) yaml_1 = load(yaml_snippet_1, schema_1) yaml_2 = load(yaml_snippet_2, schema_2) yaml_1[&amp;#39;b&amp;#39;] = yaml_2print(yaml_1.as_yaml())# Some commenta:â# value comment# Another commentb:x:8# y is now 9y:9c:-a:1-b:2 Executable specification
Page automatically generated from merge-documents.story.
 </description>
    </item>
    
    <item>
      <title>Optional keys with defaults (Map/Optional)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/optional-keys-with-defaults/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/optional-keys-with-defaults/</guid>
      <description>Experimental
This feature is in alpha. The API may change on a minor version increment.
 Example yaml_snippet:
a:1from strictyaml import Map, Int, Str, Bool, Optional, load, as_document from collections import OrderedDict from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Int(), Optional(&amp;#34;b&amp;#34;, default=False): Bool(), }) When parsed the result will include the optional value:
Ensure(load(yaml_snippet, schema).data).equals(OrderedDict([(&amp;#34;a&amp;#34;, 1), (&amp;#34;b&amp;#34;, False)])) If parsed and then output to YAML again the default data won&amp;rsquo;t be there:</description>
    </item>
    
    <item>
      <title>Parsing YAML without a schema</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/without-a-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/without-a-schema/</guid>
      <description>When using strictyaml you do not have to specify a schema. If you do this, the validator &amp;ldquo;Any&amp;rdquo; is used which will accept any mapping and any list and any scalar values (which will always be interpreted as a string, unlike regular YAML).
This is the recommended approach when rapidly prototyping and the desired schema is fluid.
When your prototype code is parsing YAML that has a more fixed structure, we recommend that you &amp;lsquo;lock it down&amp;rsquo; with a schema.</description>
    </item>
    
    <item>
      <title>Parsing comma separated items (CommaSeparated)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/comma-separated/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/comma-separated/</guid>
      <description>Comma-separated values can be validated and parsed using the CommaSeparated validator.
Note that the space following the commas is stripped by default when parsed.
from strictyaml import CommaSeparated, Int, Str, Map, load, as_document from ensure import Ensure int_schema = Map({&amp;#34;a&amp;#34;: CommaSeparated(Int())}) str_schema = Map({&amp;#34;a&amp;#34;: CommaSeparated(Str())}) Parse as int:
a:1,2,3Ensure(load(yaml_snippet, int_schema)).equals({&amp;#34;a&amp;#34;: [1, 2, 3]}) Parse as string:
a:1,2,3Ensure(load(yaml_snippet, str_schema)).equals({&amp;#34;a&amp;#34;: [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;]}) Invalid int comma separated sequence:
a:1,x,3load(yaml_snippet, int_schema)strictyaml.exceptions.YAMLValidationError: when expecting an integer in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 2, column 1: ^ (line: 2) found arbitrary text in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: 1, x, 3 ^ (line: 1) Serialize list to comma separated sequence:</description>
    </item>
    
    <item>
      <title>Parsing strings (Str)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/string/</guid>
      <description>StrictYAML parses to a YAML object, not the value directly to give you more flexibility and control over what you can do with the YAML.
This is what that can object can do - in most cases if parsed as a string, it will behave in the same way.
Example yaml_snippet:
a:1b:yesc:âstringd:| multiline stringfrom strictyaml import Str, Map, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Str(), &amp;#34;c&amp;#34;: Str(), &amp;#34;d&amp;#34;: Str()}) parsed = load(yaml_snippet, schema) Parses correctly:</description>
    </item>
    
    <item>
      <title>Reading in YAML, editing it and writing it back out</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/roundtripping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/roundtripping/</guid>
      <description>Loaded YAML can be modified and dumped out again with comments preserved using .as_yaml().
Note that due to some bugs in the library (ruamel.yaml) underlying StrictYAML, while the data parsed should be precisely the same, the exact syntax (newlines, comment locations, etc.) may not be identical.
Example yaml_snippet:
# Some commenta:â# value comment# Another commentb:x:4y:5c:-a:1-b:2from strictyaml import Map, MapPattern, EmptyDict, Str, Seq, Int, load from ensure import Ensure schema = Map({ &amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()}), &amp;#34;c&amp;#34;: EmptyDict() | Seq(MapPattern(Str(), Str())), }) Commented:</description>
    </item>
    
    <item>
      <title>Restrictions</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/</guid>
      <description> Disallowed YAML Duplicate keys Dirty load  </description>
    </item>
    
    <item>
      <title>Revalidate an already validated document</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/revalidation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/revalidation/</guid>
      <description>When parsing a YAML document you may wish to validate part of the document and then later on validate other sections within it.
This may be required because:
 One part of the document validation depends upon another (example here). It simplifies the code to apply different kinds of validation at different steps.  Example yaml_snippet:
capitals:UK:1Germany:2countries:-Germany-UKfrom strictyaml import Str, Int, Map, Seq, Any, load from ensure import Ensure overall_schema = Map({&amp;#34;capitals&amp;#34;: Any(), &amp;#34;countries&amp;#34;: Seq(Str())}) parsed = load(yaml_snippet, overall_schema) Reparse mapping:</description>
    </item>
    
    <item>
      <title>Scalar StrictYAML Validators</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/</guid>
      <description> Validating strings with regexes (Regex) Parsing comma separated items (CommaSeparated) Datetimes (Datetime) Empty key validation Decimal numbers (Decimal) Boolean (Bool) Integers (Int) Enumerated scalars (Enum) Floating point numbers (Float) Email and URL validators Parsing strings (Str)  </description>
    </item>
    
    <item>
      <title>Sequence/list validator (Seq)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/sequences/</guid>
      <description>Sequences in YAML are denoted by a series of dashes (&amp;lsquo;-&amp;rsquo;) and parsed as a list in python.
Validating sequences of a particular type can be done with the Seq validator, specifying the type.
See also UniqueSeq and FixedSeq for other types of sequence validation.
Example yaml_snippet:
-1-2-3from strictyaml import Seq, Str, Int, load from ensure import Ensure Valid Parsed:
Ensure(load(yaml_snippet, Seq(Str()))).equals([&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, ]) Is sequence:
assert load(yaml_snippet, Seq(Str())).is_sequence() Iterator:</description>
    </item>
    
    <item>
      <title>Sequences of unique items (UniqueSeq)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/sequences-of-unique-items/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/sequences-of-unique-items/</guid>
      <description>UniqueSeq validates sequences which contain no duplicate values.
Example yaml_snippet:
-A-B-Cfrom strictyaml import UniqueSeq, Str, load, as_document from ensure import Ensure schema = UniqueSeq(Str()) Valid:
Ensure(load(yaml_snippet, schema)).equals([&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, ]) Parsing with one dupe raises an exception:
-A-B-Bload(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: while parsing a sequence in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: - A ^ (line: 1) duplicate found in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 3, column 1: - B ^ (line: 3) Parsing all dupes raises an exception:</description>
    </item>
    
    <item>
      <title>StrictYAML</title>
      <link>https://hitchdev.com/strictyaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/</guid>
      <description>StrictYAML is a type-safe YAML parser that parses and validates a restricted subset of the YAML specification.
Priorities:
 Beautiful API Refusing to parse the ugly, hard to read and insecure features of YAML. Strict validation of markup and straightforward type casting. Clear, readable exceptions with code snippets and line numbers. Acting as a near-drop in replacement for pyyaml, ruamel.yaml or poyo. Ability to read in YAML, make changes and write it out again with comments preserved.</description>
    </item>
    
    <item>
      <title>The Norway Problem - why StrictYAML won&#39;t do implicit typing</title>
      <link>https://hitchdev.com/strictyaml/why/implicit-typing-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/implicit-typing-removed/</guid>
      <description>A while back I met an old coworker for a beer and he started telling me about this interesting internationalization bug he faced.
&amp;ldquo;So, we started internationalizing the website and I added a few more countries - France, Germany, etc. to the configuration file&amp;rdquo;
countries:-GB-IE-FR-DE &amp;ldquo;This was fine for a while. Then eventually we got around to adding Norway&amp;hellip;&amp;rdquo;
countries:-GB-IE-FR-DE-NO &amp;ldquo;and then, suddenly, everything broke&amp;hellip;&amp;rdquo;
The problem here is &amp;ldquo;implicit typing&amp;rdquo; - the YAML specification states that the parser should be &amp;lsquo;smart&amp;rsquo; about the strings that are entered in to it and attempt to convert them into the relevant types for you.</description>
    </item>
    
    <item>
      <title>Using StrictYAML</title>
      <link>https://hitchdev.com/strictyaml/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/</guid>
      <description>How to:
 Get line numbers of YAML elements Revalidate an already validated document Build a YAML document from scratch in code Reading in YAML, editing it and writing it back out Labeling exceptions Merge YAML documents Either/or schema validation of different, equally valid different kinds of YAML Parsing YAML without a schema  Compound validators:
 Using a YAML object of a parsed mapping Sequence/list validator (Seq) Sequences of unique items (UniqueSeq) Mapping with defined keys and a custom key validator (Map) Fixed length sequences (FixedSeq) Mappings with arbitrary key names (MapPattern) Optional keys with defaults (Map/Optional) Mappings with defined keys (Map) Validating optional keys in mappings (Map)  Scalar validators:</description>
    </item>
    
    <item>
      <title>Using StrictYAML v0.x.x</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Using a YAML object of a parsed mapping</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-yaml-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-yaml-object/</guid>
      <description>When a YAML document with mappings is parsed, it is not parsed as a dict but as a YAML object which behaves very similarly to a dict, but with some extra capabilities.
You can use .items(), .keys(), .values(), look up items with square bracket notation, .get(key, with_default_if_nonexistent) and use &amp;ldquo;x in y&amp;rdquo; notation to determine key membership.
To retrieve the equivalent dict (containing just other dicts, lists and strings/ints/etc.) use .</description>
    </item>
    
    <item>
      <title>Validating optional keys in mappings (Map)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/optional-keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/optional-keys/</guid>
      <description>Not every key in a YAML mapping will be required. If you use the &amp;ldquo;Optional(&amp;lsquo;key&amp;rsquo;)&amp;rdquo; validator with YAML, you can signal that a key/value pair is not required.
from strictyaml import Map, Int, Str, Bool, Optional, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Int(), Optional(&amp;#34;b&amp;#34;): Bool(), }) Valid example 1:
a:1b:yesEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: True}) Valid example 2:
a:1b:noEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: False}) Valid example missing key:
a:1Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1}) Invalid 1:</description>
    </item>
    
    <item>
      <title>Validating strings with regexes (Regex)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/regular-expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/regular-expressions/</guid>
      <description>StrictYAML can validate regular expressions and return a string. If the regular expression does not match, an exception is raised.
from strictyaml import Regex, Map, load, as_document from collections import OrderedDict from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Regex(u&amp;#34;[1-4]&amp;#34;), &amp;#34;b&amp;#34;: Regex(u&amp;#34;[5-9]&amp;#34;)}) Parsed correctly:
a:1b:5Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;5&amp;#34;}) Non-matching:
a:5b:5load(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: when expecting string matching [1-4] found non-matching string in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: &amp;#39;5&amp;#39; ^ (line: 1) Serialized successfully:</description>
    </item>
    
    <item>
      <title>What YAML features does StrictYAML remove?</title>
      <link>https://hitchdev.com/strictyaml/features-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/features-removed/</guid>
      <description>StrictYAML restricts you from parsing a number of things which the YAML specification says should be parsed. An issue has been raised by David Seaward about this critique on the official YAML repository.
This document lists those of those features:
Implicit Typing (Why?) x:yesy:null Example pyyaml/ruamel/poyo:
load(yaml) == {&amp;#34;x&amp;#34;: True, &amp;#34;y&amp;#34;: None}  Example StrictYAML without schema:
load(yaml) == {&amp;#34;x&amp;#34;: &amp;#34;yes&amp;#34;, &amp;#34;y&amp;#34;: &amp;#34;null&amp;#34;} Example StrictYAML with schema:
load(yaml, Map({&amp;#34;x&amp;#34;: Bool(), &amp;#34;y&amp;#34;: Str()})) == {&amp;#34;x&amp;#34;: True, &amp;#34;y&amp;#34;: &amp;#34;null&amp;#34;} Direct representations of objects (Why?</description>
    </item>
    
    <item>
      <title>What is YAML?</title>
      <link>https://hitchdev.com/strictyaml/what-is-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/what-is-yaml/</guid>
      <description>YAML is a simple, human readable format for representing associative and hierarchical data.
Example from wikipedia page on YAML:
receipt:Oz-WarePurchaseInvoicedate:2012-08-06customer:firstname:Harryfamilyname:Potteraddress:|-4PrivetDrive,LittleWhinging,Englanditems:-part_no:A4786description:WaterBucket(Filled)price:1.47quantity:4-part_no:E1628description:HighHeeled&amp;#34;Ruby&amp;#34;Slipperssize:8price:133.7quantity:1 Key features:
 Things which are associated with other things - delimited by the colon (:). Ordered lists of things - delimited by the prepended dash (-). Multi-line strings - delimited by the bar (|) if there is another newline at the end of the string, or bar + dash (|-) if not.</description>
    </item>
    
    <item>
      <title>What is wrong with duplicate keys?</title>
      <link>https://hitchdev.com/strictyaml/why/duplicate-keys-disallowed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/duplicate-keys-disallowed/</guid>
      <description>Duplicate keys are allowed in regular YAML - as parsed by pyyaml, ruamel.yaml and poyo:
x:cowy:dogx:bull Not only is it unclear whether x should be &amp;ldquo;cow&amp;rdquo; or &amp;ldquo;bull&amp;rdquo; (the parser will decide &amp;lsquo;bull&amp;rsquo;, but did you know that?), if there are 200 lines between x: cow and x: bull, a user might very likely change the first x and erroneously believe that the resulting value of x has been changed - when it hasn&amp;rsquo;t.</description>
    </item>
    
    <item>
      <title>What is wrong with explicit syntax typing in a readable configuration language?</title>
      <link>https://hitchdev.com/strictyaml/why/syntax-typing-bad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/syntax-typing-bad/</guid>
      <description>Explicit syntax typing is the process of using syntax to define types in markup. So, for instance in JSON, quotation marks are used to define name as a string and age as a number:
{&amp;#34;name&amp;#34;: &amp;#34;Arthur Dent&amp;#34;, &amp;#34;age&amp;#34;: 42} This helps distinguish the types for the parser, which is useful for JSON, but it also comes with two disadvantages:
 The distinction is subtle and not particularly clear to non-programmers, who will not necessarily understand that a directive needs to be given to the parser to avoid it being misinterpreted.</description>
    </item>
    
    <item>
      <title>What is wrong with explicit tags?</title>
      <link>https://hitchdev.com/strictyaml/why/explicit-tags-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/explicit-tags-removed/</guid>
      <description>Explicit tags are tags that have an explicit type attached that is used to determine what type to convert the data to when it is parsed.
For example, if it were to be applied to &amp;ldquo;fix&amp;rdquo; the Godfather movie script parsing issue described above, it would look like this:
-DonCorleone:Doyouhavefaithinmyjudgment?-Clemenza:!!strYes-DonCorleone:DoIhaveyourloyalty? Explicit typecasts in YAML markup are slightly confusing for non-programmers, much like the concept of &amp;lsquo;types&amp;rsquo; in general. StrictYAML&amp;rsquo;s philosophy is that types should be kept strictly separated from data, so this &amp;lsquo;feature&amp;rsquo; of YAML is switched off.</description>
    </item>
    
    <item>
      <title>What is wrong with flow style YAML?</title>
      <link>https://hitchdev.com/strictyaml/why/flow-style-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/flow-style-removed/</guid>
      <description>Flow style is essentially JSON embedded in YAML - making use of curly { } and square brackets to denote lists and mappings.
Example:
a:1b:{c:3,d:4} This use of JSONesque { and } is also ugly and hampers readability - especially when { and } are used for other purposes (e.g. templating) and the human reader/writer of YAML has to give themselves a headache figuring out what kind of curly bracket it is.</description>
    </item>
    
    <item>
      <title>What is wrong with node anchors and references?</title>
      <link>https://hitchdev.com/strictyaml/why/node-anchors-and-references-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/node-anchors-and-references-removed/</guid>
      <description>An example of a snippet of YAML that uses node anchors and references is described on the YAML wikipedia page:
# sequencer protocols for Laser eye surgery----step:&amp;amp;id001# defines anchor label &amp;amp;id001instrument:Lasik2000pulseEnergy:5.4pulseDuration:12repetition:1000spotSize:1mm-step:&amp;amp;id002instrument:Lasik2000pulseEnergy:5.0pulseDuration:10repetition:500spotSize:2mm-step:*id001# refers to the first step (with anchor &amp;amp;id001)-step:*id002# refers to the second step-step:&amp;lt;&amp;lt;:*id001spotSize:2mm# redefines just this key, refers rest from &amp;amp;id001-step:*id002 While the intent of the feature is obvious (it lets you deduplicate code), the effect is to make the markup more or less unreadable to non-programmers.</description>
    </item>
    
    <item>
      <title>When should I use a validator and when should I not?</title>
      <link>https://hitchdev.com/strictyaml/when-to-use-validators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/when-to-use-validators/</guid>
      <description>When starting out on greenfield projects it&amp;rsquo;s much quicker not to create a validator. In such cases it&amp;rsquo;s often more prudent to just parse the YAML and convert the strings explicitly on the fly (e.g. int(yaml[&amp;lsquo;key&amp;rsquo;])).
If the YAML is also going to be largely under the control of the developer it also might not make sense to write a validator either.
If you have written software that is going to parse YAML from a source you do not control - especially by somebody who might make a mistake - then it probably does make sense to write a validator.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML make you define a schema in python - a turing complete language?</title>
      <link>https://hitchdev.com/strictyaml/why/turing-complete-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/turing-complete-schema/</guid>
      <description>StrictYAML defines schemas in python (i.e. turing complete) code. For example:
Map({&amp;#34;name&amp;#34;: Str(), &amp;#34;email&amp;#34;: Str()}) Instead of:
type:mapmapping:&amp;#34;name&amp;#34;:type:strrequired:yes&amp;#34;email&amp;#34;:type:strrequired:yes There are some trade offs here:
Schema definition in a non-turing complete language like YAML makes the schema programming language independent and gives it more potential for being read and understood by non-programmers.
However, schema definition in a non-turing complete language also restricts and makes certain use cases impossible or awkward.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML not parse direct representations of python objects?</title>
      <link>https://hitchdev.com/strictyaml/why/not-parse-direct-representations-of-python-objects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/not-parse-direct-representations-of-python-objects/</guid>
      <description>Regular YAML allows the direct representation of python objects.
For example:
---!python/hash:UserObjectemail:evilhacker@hacker.compassword:passwordtosettype:admin If we load this YAML formatted string in, we get a user object. This was how YAML was intended to work since it allows the ability to write objects to and read them from, say, a database.
By itself, this behavior isn&amp;rsquo;t necessarily capable of enacting a successful attack, so not all code that parses untrusted YAML is insecure, but it can be used, especially in conjunction with metaprogramming to execute arbitrary code on your system.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML only parse from strings and not files?</title>
      <link>https://hitchdev.com/strictyaml/why/only-parse-strings-not-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/only-parse-strings-not-files/</guid>
      <description>While other parsers will take strings, file handles and file names, StrictYAML will only parse YAML strings.
This is done deliberately to reduce the module&amp;rsquo;s remit, with the intention of reducing both the potential bug surface and the number of exceptions that StrictYAML has to deal with - things like nonexistent files, file system errors, bad reads, unknown file extensions, etc. become the problem of some other module - ideally one more focused on handling those kinds of issues.</description>
    </item>
    
    <item>
      <title>Why is parsing speed not a high priority for StrictYAML?</title>
      <link>https://hitchdev.com/strictyaml/why/speed-not-a-priority/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/speed-not-a-priority/</guid>
      <description>JSON and StrictYAML are essentially complementary formats. They both allow a relatively loose representation of data that just contains, mappings and sequences. They are serialization formats that are relatively straightforward for both humans and machines to read and write.
The main difference is simply one of degree:
JSON is primariliy optimized for machine readability and writability, while still maintaining human readability.
YAML is optimized for human readability and writability, while maintaining machine readability and writability.</description>
    </item>
    
    <item>
      <title>Why not HOCON?</title>
      <link>https://hitchdev.com/strictyaml/why-not/hocon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/hocon/</guid>
      <description>HOCON is another &amp;ldquo;redesigned&amp;rdquo; JSON, ironically enough, taking JSON and making it even more complicated.
Along with JSON&amp;rsquo;s syntax typing - a downside of most non-YAML alternatives, HOCON makes the following mistakes in its design:
 It does not fail loudly on duplicate keys. It has a confusing rules for deciding on concatenations and substitutions. -* It has a mechanism for substitutions similar to YAML&amp;rsquo;s node/anchor feature - which, unless used extremely sparingly, can create confusing markup that, ironically, is not human optimized.</description>
    </item>
    
    <item>
      <title>Why not JSON for simple configuration files?</title>
      <link>https://hitchdev.com/strictyaml/why-not/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/json/</guid>
      <description>JSON is an ideal format for REST APIs and other forms of data intended for machine exchange and it probably always will be because:
 It&amp;rsquo;s a simple spec. It has all the basic types which map on to all programming languages - number, string, list, mapping, boolean and no more. Its syntax contains a built in level of error detection - cut a JSON request in half and it is no longer still valid, eliminating an entire class of obscure and problematic bugs.</description>
    </item>
    
    <item>
      <title>Why not JSON5?</title>
      <link>https://hitchdev.com/strictyaml/why-not/json5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/json5/</guid>
      <description>JSON5 is also a proposed extension to JSON to make it more readable.
Its main criticism of YAML is::
There are other formats that are human-friendlier, like YAML, but changing from JSON to a completely different format is undesirable in many cases.
This is, I belive, mistaken. It is better if a language is not subtly different if you are going to use it as such. Subtle differences invite mistakes brought on by confusion.</description>
    </item>
    
    <item>
      <title>Why not X?</title>
      <link>https://hitchdev.com/strictyaml/why-not/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/</guid>
      <description>There are a number of formats and approaches that can achieve more or less the same purpose as StrictYAML. Below is a series of comparisons with some of the more famous ones:
 Why not JSON for simple configuration files? Why not use TOML? Why not use the YAML 2.0 standard? - we don&amp;rsquo;t need a new standard! Why not use kwalify with standard YAML to validate my YAML? Why not use python&amp;rsquo;s schema library for validation?</description>
    </item>
    
    <item>
      <title>Why not use INI files?</title>
      <link>https://hitchdev.com/strictyaml/why-not/ini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/ini/</guid>
      <description>INI is a very old and quite readable configuration format. Unfortunately it suffers from two major problems:
 Different parsers will operate in subtly different ways that can lead to often obscure bugs regarding the way whitespace is used, case sensitivity, comments and escape characters. It doesn&amp;rsquo;t let you represent hierarchical data.  In a way, TOML</description>
    </item>
    
    <item>
      <title>Why not use JSON Schema for validation?</title>
      <link>https://hitchdev.com/strictyaml/why-not/json-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/json-schema/</guid>
      <description>JSON schema can also be used to validate YAML. This presumes that you might want to use jsonschema and pyyaml/ruamel.yaml together.
[ TODO Flesh out ]
 Line numbers Simpler errors in StrictYAML StrictYAML is a more flexible schema Turing incompleteness / inflexibility  </description>
    </item>
    
    <item>
      <title>Why not use SDLang?</title>
      <link>https://hitchdev.com/strictyaml/why-not/sdlang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/sdlang/</guid>
      <description>SDLang or &amp;ldquo;simple declarative language&amp;rdquo; is a proposed configuration language with an XML-like structure inspired by C.
Example:
// This is a node with a single string value title &amp;quot;Hello, World&amp;quot; // Multiple values are supported, too bookmarks 12 15 188 1234 // Nodes can have attributes author &amp;quot;Peter Parker&amp;quot; email=&amp;quot;peter@example.org&amp;quot; active=true // Nodes can be arbitrarily nested contents { section &amp;quot;First section&amp;quot; { paragraph &amp;quot;This is the first paragraph&amp;quot; paragraph &amp;quot;This is the second paragraph&amp;quot; } } // Anonymous nodes are supported &amp;quot;This text is the value of an anonymous node!</description>
    </item>
    
    <item>
      <title>Why not use TOML?</title>
      <link>https://hitchdev.com/strictyaml/why-not/toml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/toml/</guid>
      <description>TOML is a redesigned configuration language that&amp;rsquo;s essentially an extended version of INI which allows the expression of both hierarchical and typed data.
TOML&amp;rsquo;s main criticism of YAML is spot on:
TOML aims for simplicity, a goal which is not apparent in the YAML specification.  Yet StrictYAML&amp;rsquo;s cut down version of the YAML specification - with implicit typing, node anchors/references and flow style cut out, is simpler than both standard YAML and TOML.</description>
    </item>
    
    <item>
      <title>Why not use XML for configuration or DSLs?</title>
      <link>https://hitchdev.com/strictyaml/why-not/xml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/xml/</guid>
      <description>XML suffers from overcomplication much like vanilla YAML does - although to an ever greater degree, thanks to the committee driven design. Doctypes and namespaces are horrendous additions to the language, for instance. XML is not only not really human readable (beyond a very basic subset of the language), it&amp;rsquo;s often barely programmer readable despite being less expressive than most turing complete languages. It&amp;rsquo;s a flagrant violation of the rule of least power.</description>
    </item>
    
    <item>
      <title>Why not use kwalify with standard YAML to validate my YAML?</title>
      <link>https://hitchdev.com/strictyaml/why-not/pykwalify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/pykwalify/</guid>
      <description>Kwalify is a schema validation language that is written in YAML.
It is a descriptive schema language suitable for validating simple YAML.
Kwalify compiles to the strictyaml equivalent but is able to do less. You cannot, for example:
 Plug generated lists that come from outside of the spec (e.g. a list of country code from pycountry). Validate parts of the schema which can be either one thing or another - e.</description>
    </item>
    
    <item>
      <title>Why not use python&#39;s schema library for validation?</title>
      <link>https://hitchdev.com/strictyaml/why-not/python-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/python-schema/</guid>
      <description>Python&amp;rsquo;s &amp;lsquo;schema&amp;rsquo; (as well as similar libraries) can also be used to validate the structure of objects. Validating YAML is even cited as a reason on their README.
Problems:
 Line numbers and code snippets not reported on errors. YAML&amp;rsquo;s implicit typing will still ruin validation. Roundtripping is much less straightforward.  [ TODO flesh out ]</description>
    </item>
    
    <item>
      <title>Why not use the YAML 2.0 standard? - we don&#39;t need a new standard!</title>
      <link>https://hitchdev.com/strictyaml/why-not/ordinary-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/ordinary-yaml/</guid>
      <description>StrictYAML is composed of two parts:
 A new YAML specification which parses a restricted subset of the YAML 2.0 specification and only parse to ordered dict, list or string. An optional validator (which will, as requested, validate and cast parse some of those scalar string values to ints, floats, datetimes, etc.).  Note that StrictYAML is not a new standard. If you have a syntax highlighter or editor or anything else that recognizes or reads YAML it will recognize StrictYAML in the same way.</description>
    </item>
    
    <item>
      <title>Why shouldn&#39;t I just use python code for configuration?</title>
      <link>https://hitchdev.com/strictyaml/why-not/turing-complete-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/turing-complete-code/</guid>
      <description>This isn&amp;rsquo;t uncommon and can often seem like a nice, simple solution although using a turing complete language for configuration will often have nasty side effects.
Why does using YAML (or indeed, any configuration language) avoid this? Because they are less powerful languages than python.
While this may not intrinsically seem like a good thing (more power seems better at first glance), it isn&amp;rsquo;t:
 We need less powerful languages. Rule of least power (wikipedia).</description>
    </item>
    
  </channel>
</rss>
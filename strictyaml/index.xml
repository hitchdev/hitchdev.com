<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Strictyamls on HitchDev</title>
    <link>http://hitchdev.com/strictyaml/</link>
    <description>Recent content in Strictyamls on HitchDev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (C) 2017</copyright>
    
	<atom:link href="http://hitchdev.com/strictyaml/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>http://hitchdev.com/strictyaml/new-faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/new-faq/</guid>
      <description>docs/why/features-removed.rst
docs/what-is-yaml.rst
docs/why/care-about-yaml.rst
docs/when/validators.rst
docs/why-not/ordinary-yaml.rst
docs/why-not/syntax-typing.rst
docs/why/implicit-typing-disallowed.rst
docs/why/binary-data-disallowed.rst
docs/why/explicit-tags-disallowed.rst
docs/why/node-anchors-and-references-disallowed.rst
docs/why/flow-style-disallowed.rst
docs/why-not/duplicate-keys-disallowed.rst
docs/why-not/ini.rst
docs/why-not/turing-complete-code.rst
docs/why-not/xml.rst
docs/why-not/json.rst
docs/why-not/toml.rst
docs/why-not/hocon.rst
docs/why-not/hjson.rst
docs/why-not/json5.rst
docs/why-not/sdlang.rst
docs/why-not/pykwalify.rst
docs/why-not/disagree.rst</description>
    </item>
    
    <item>
      <title>Compound StrictYAML Validators</title>
      <link>http://hitchdev.com/strictyaml/using/alpha/compound/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/using/alpha/compound/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Design Justifications</title>
      <link>http://hitchdev.com/strictyaml/why/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/</guid>
      <description>StrictYAML is the result of some carefully considered, although controversial design decisions. These are justified here.
 What is wrong with explicit tags? What is wrong with explicit syntax typing in a readable configuration language? What is wrong with implicit typing? What is wrong with flow style YAML? Why does StrictYAML only parse from strings and not files? What is wrong with duplicate keys? Why does StrictYAML not parse direct representations of python objects?</description>
    </item>
    
    <item>
      <title>How to...</title>
      <link>http://hitchdev.com/strictyaml/using/alpha/howto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/using/alpha/howto/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Restrictions</title>
      <link>http://hitchdev.com/strictyaml/using/alpha/restrictions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/using/alpha/restrictions/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Scalar StrictYAML Validators</title>
      <link>http://hitchdev.com/strictyaml/using/alpha/scalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/using/alpha/scalar/</guid>
      <description></description>
    </item>
    
    <item>
      <title>StrictYAML</title>
      <link>http://hitchdev.com/strictyaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/</guid>
      <description>StrictYAML is a type-safe YAML parser that parses a restricted subset of the YAML specificaton.
Priorities:
 Beautiful API Refusing to parse the ugly, hard to read and insecure features of YAML. Strict validation of markup and straightforward type casting. Clear, readable exceptions with code snippets and line numbers. Acting as a near-drop in replacement for pyyaml, ruamel.yaml or poyo. Ability to read in YAML, make changes and write it out again with comments preserved.</description>
    </item>
    
    <item>
      <title>Using StrictYAML</title>
      <link>http://hitchdev.com/strictyaml/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/using/</guid>
      <description>How to:
Compound validators:
Scalar validators:
Restrictions:</description>
    </item>
    
    <item>
      <title>Using StrictYAML v0.x.x</title>
      <link>http://hitchdev.com/strictyaml/using/alpha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/using/alpha/</guid>
      <description></description>
    </item>
    
    <item>
      <title>What YAML features does StrictYAML remove?</title>
      <link>http://hitchdev.com/strictyaml/features-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/features-removed/</guid>
      <description>StrictYAML restricts you from parsing a number of things which the YAML specification says should be parsed.
This is a demonstration of some of those features:
Implicit Typing x:yesy:null Example pyyaml/ruamel/poyo:
load(yaml) == {&amp;#34;x&amp;#34;: True, &amp;#34;y&amp;#34;: None}  Example StrictYAML
load(yaml) == {&amp;#34;x&amp;#34;: &amp;#34;yes&amp;#34;, &amp;#34;y&amp;#34;: &amp;#34;null&amp;#34;} Direct representations of objects ---!python/hash:UnsafeUserObjectemail:evilhacker@hacker.compassword:passwordtosettype:admin Example pyyaml/ruamel:
load(yaml) == {&amp;#39;evil&amp;#39;: b&amp;#39;z\xf8\xa5u\xabZ&amp;#39;} Example StrictYAML
raises TagTokenDisallowed Duplicate Keys Disallowed x:1x:2 Example pyyaml/poyo:
load(yaml) == {&amp;#39;x&amp;#39;: 2} Example StrictYAML</description>
    </item>
    
    <item>
      <title>What is YAML?</title>
      <link>http://hitchdev.com/strictyaml/what-is-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/what-is-yaml/</guid>
      <description>YAML is a simple, human readable format for representing associative and hierarchical data.
Example from wikipedia page on YAML:
receipt:Oz-WarePurchaseInvoicedate:2012-08-06customer:firstname:Harryfamilyname:Potteraddress:|-4PrivetDrive,LittleWhinging,Englanditems:-part_no:A4786description:WaterBucket(Filled)price:1.47quantity:4-part_no:E1628description:HighHeeled&amp;#34;Ruby&amp;#34;Slipperssize:8price:133.7quantity:1 Key features:
 Things which are associated with other things - delimited by the colon (:). Ordered lists of things - delimited by the prepended dash (-). Multi-line strings - delimited by the bar (|) if there is another newline at the end of the string, or bar + dash (|-) if not.</description>
    </item>
    
    <item>
      <title>What is wrong with duplicate keys?</title>
      <link>http://hitchdev.com/strictyaml/why/duplicate-keys-disallowed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/duplicate-keys-disallowed/</guid>
      <description>Duplicate keys are allowed in regular YAML - as parsed by pyyaml, ruamel.yaml and poyo:
x:cowy:dogx:bull Not only is it unclear whether x should be &amp;ldquo;cow&amp;rdquo; or &amp;ldquo;bull&amp;rdquo; (the parser will decide &amp;lsquo;bull&amp;rsquo;, but did you know that?), if there are 200 lines between x: cow and x: bull, a user might very likely change the first x and erroneously believe that the resulting value of x has been changed - when it hasn&amp;rsquo;t.</description>
    </item>
    
    <item>
      <title>What is wrong with explicit syntax typing in a readable configuration language?</title>
      <link>http://hitchdev.com/strictyaml/why/syntax-typing-bad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/syntax-typing-bad/</guid>
      <description>Explicit syntax typing is the process of using syntax to define types in markup. So, for instance in JSON, quotation marks are used to define name as a string and age as a number:
´´´json {&amp;ldquo;name&amp;rdquo;: &amp;ldquo;Arthur Dent&amp;rdquo;, &amp;ldquo;age&amp;rdquo;: 42} ´´´
This helps distinguish the types for the parser, which is useful for JSON, but it also comes with two disadvantages:
 The distinction is subtle and not particularly clear to non-programmers, who will not necessarily understand that a directive needs to be given to the parser to avoid it being misinterpreted.</description>
    </item>
    
    <item>
      <title>What is wrong with explicit tags?</title>
      <link>http://hitchdev.com/strictyaml/why/explicit-tags-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/explicit-tags-removed/</guid>
      <description>Explicit tags are tags that have an explicit type attached that is used to determine what type to convert the data to when it is parsed.
For example, if it were to be applied to &amp;ldquo;fix&amp;rdquo; the Godfather movie script parsing issue described above, it would look like this:
-DonCorleone:Doyouhavefaithinmyjudgment?-Clemenza:!!strYes-DonCorleone:DoIhaveyourloyalty? Explicit typecasts in YAML markup are not only ugly, they confuse non-programmers. StrictYAML&amp;rsquo;s philosophy is that type information should be kept strictly separated from data, so this &amp;lsquo;feature&amp;rsquo; of YAML is switched off.</description>
    </item>
    
    <item>
      <title>What is wrong with flow style YAML?</title>
      <link>http://hitchdev.com/strictyaml/why/flow-style-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/flow-style-removed/</guid>
      <description>Flow style is essentially JSON embedded in YAML - making use of curly { } and square brackets to denote lists and mappings.
Example:
a:1b:{c:3,d:4} This use of JSONesque { and } is also ugly and hampers readability - especially when { and } are used for other purposes (e.g. templating) and the human reader/writer of YAML has to give themselves a headache figuring out what kind of curly bracket it is.</description>
    </item>
    
    <item>
      <title>What is wrong with implicit typing?</title>
      <link>http://hitchdev.com/strictyaml/why/implicit-typing-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/implicit-typing-removed/</guid>
      <description>Imagine you are parsing a DSL to represent movie scripts:
-DonCorleone:Doyouhavefaithinmyjudgment?-Clemenza:Yes-DonCorleone:DoIhaveyourloyalty? Parse output of pyyaml, ruamel.yaml and Poyo:
&amp;gt;&amp;gt;&amp;gt; from ruamel.yaml import load &amp;gt;&amp;gt;&amp;gt; load(the_godfather) [{&amp;#39;Don Corleone&amp;#39;: &amp;#39;Do you have faith in my judgement?&amp;#39;}, {&amp;#39;Clemenza&amp;#39;: True}, {&amp;#39;Don Corleone&amp;#39;: &amp;#39;Do I have your loyalty?&amp;#39;},] Wait, Clemenza said what??
Parse output of StrictYAML without validators:
&amp;gt;&amp;gt;&amp;gt; from strictyaml import load, List, MapPattern, Str &amp;gt;&amp;gt;&amp;gt; load(the_godfather) [{&amp;#39;Don Corleone&amp;#39;: &amp;#39;Do you have faith in my judgement?</description>
    </item>
    
    <item>
      <title>What is wrong with node anchors and references?</title>
      <link>http://hitchdev.com/strictyaml/why/node-anchors-and-references-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/node-anchors-and-references-removed/</guid>
      <description>An example of a snippet of YAML that uses node anchors and references is described on the YAML wikipedia page:
# sequencer protocols for Laser eye surgery----step:&amp;amp;id001# defines anchor label &amp;amp;id001instrument:Lasik2000pulseEnergy:5.4pulseDuration:12repetition:1000spotSize:1mm-step:&amp;amp;id002instrument:Lasik2000pulseEnergy:5.0pulseDuration:10repetition:500spotSize:2mm-step:*id001# refers to the first step (with anchor &amp;amp;id001)-step:*id002# refers to the second step-step:&amp;lt;&amp;lt;:*id001spotSize:2mm# redefines just this key, refers rest from &amp;amp;id001-step:*id002 While the intent of the feature is obvious (it lets you deduplicate code), the effect is to make the markup more or less unreadable to non-programmers.</description>
    </item>
    
    <item>
      <title>When should I use a validator and when should I not?</title>
      <link>http://hitchdev.com/strictyaml/when-to-use-validators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/when-to-use-validators/</guid>
      <description>When starting out on greenfield projects it&amp;rsquo;s much quicker not to create a validator. In such cases it&amp;rsquo;s often more prudent to just parse the YAML and convert the strings explicitly on the fly (e.g. int(yaml[&amp;lsquo;key&amp;rsquo;])).
If the YAML is also going to be largely under the control of the developer it also might not make sense to write a validator either.
If you have written software that is going to parse YAML from a source you do not control - especially by somebody who might make a mistake - then it probably does make sense to write a validator.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML make you define a schema in python - a turing complete language?</title>
      <link>http://hitchdev.com/strictyaml/why/turing-complete-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/turing-complete-schema/</guid>
      <description>StrictYAML defines schemas in python (i.e. turing complete) code. For example:
Map({&amp;#34;name&amp;#34;: Str(), &amp;#34;email&amp;#34;: Str()}) Instead of:
type:mapmapping:&amp;#34;name&amp;#34;:type:strrequired:yes&amp;#34;email&amp;#34;:type:strrequired:yes There are some trade offs here:
Schema definition in a non-turing complete language like YAML makes the schema programming language independent and gives it more potential for being read and understood by non-programmers.
However, schema definition in a non-turing complete language also restricts and makes certain use cases impossible or awkward.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML not parse direct representations of python objects?</title>
      <link>http://hitchdev.com/strictyaml/why/binary-data-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/binary-data-removed/</guid>
      <description>StrictYAML doesn&amp;rsquo;t allow direct representations of python objects. For example:
---!python/hash:UnsafeUserObjectemail:evilhacker@hacker.compassword:passwordtosettype:admin This anti-feature led to Ruby on Rails&amp;rsquo; spectacular security fail.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML only parse from strings and not files?</title>
      <link>http://hitchdev.com/strictyaml/why/only-parse-strings-not-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/only-parse-strings-not-files/</guid>
      <description>While other parsers will take strings, file handles and file names, StrictYAML will only parse YAML strings.
This is done deliberately to reduce the module&amp;rsquo;s remit, with the intention of reducing both the potential bug surface and the number of exceptions that StrictYAML has to deal with - things like nonexistent files, file system errors, bad reads, unknown file extensions, etc. become the problem of some other module - ideally one more focused on handling those kinds of issues.</description>
    </item>
    
    <item>
      <title>Why is parsing speed not a high priority for StrictYAML?</title>
      <link>http://hitchdev.com/strictyaml/why/speed-not-a-priority/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why/speed-not-a-priority/</guid>
      <description>JSON and StrictYAML are essentially complementary formats. They both allow a relatively loose representation of data that just contains, mappings and sequences. They are serialization formats that are relatively straightforward for both humans and machines to read and write.
The main difference is simply one of degree:
JSON is primariliy optimized for machine readability and writability, while still maintaining human readability.
YAML is optimized for human readability and writability, while maintaining machine readability and writability.</description>
    </item>
    
    <item>
      <title>Why not HOCON?</title>
      <link>http://hitchdev.com/strictyaml/why-not/hocon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/hocon/</guid>
      <description>HOCON is another &amp;ldquo;redesigned&amp;rdquo; JSON, ironically enough, taking JSON and making it even more complicated.
Along with JSON&amp;rsquo;s syntax typing - a downside of most non-YAML alternatives, HOCON makes the following mistakes in its design:
 It does not fail loudly on duplicate keys. It has a confusing rules for deciding on concatenations and substitutions. -* It has a mechanism for substitutions similar to YAML&amp;rsquo;s node/anchor feature - which, unless used extremely sparingly, can create confusing markup that, ironically, is not human optimized.</description>
    </item>
    
    <item>
      <title>Why not JSON for simple configuration files?</title>
      <link>http://hitchdev.com/strictyaml/why-not/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/json/</guid>
      <description>JSON is an ideal format for REST APIs and other forms of data intended for machine exchange and it probably always will be because:
 It&amp;rsquo;s a simple spec. It has all the basic types which map on to all programming languages - number, string, list, mapping, boolean and no more. Its syntax contains a built in level of error detection - cut a JSON request in half and it is no longer still valid, eliminating an entire class of obscure and problematic bugs.</description>
    </item>
    
    <item>
      <title>Why not JSON5?</title>
      <link>http://hitchdev.com/strictyaml/why-not/json5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/json5/</guid>
      <description>JSON5 is also a proposed extension to JSON to make it more readable.
Its main criticism of YAML is::
There are other formats that are human-friendlier, like YAML, but changing from JSON to a completely different format is undesirable in many cases.
This is, I belive, mistaken. It is better if a language is not subtly different if you are going to use it as such. Subtle differences invite mistakes brought on by confusion.</description>
    </item>
    
    <item>
      <title>Why not X?</title>
      <link>http://hitchdev.com/strictyaml/why-not/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/</guid>
      <description>There are a number of formats and approaches that can achieve more or less the same purpose as StrictYAML. I&amp;rsquo;ve tried to make it the best one. Below is a series of documented justifications:
 Why not JSON for simple configuration files? Why not use HJSON? Why not use TOML? Why not use the YAML 2.0 standard? - we don&amp;rsquo;t need a new standard! Why not use kwalify with standard YAML to validate my YAML?</description>
    </item>
    
    <item>
      <title>Why not use HJSON?</title>
      <link>http://hitchdev.com/strictyaml/why-not/hjson/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/hjson/</guid>
      <description>HJSON is an attempt at fixing the aforementioned lack of readability of JSON.
It has the following criticisms of YAML:
 JSON is easier to explain (compare the JSON and YAML specs).
 JSON is not bloated (it does not have anchors, substitutions or concatenation).
  As with TOML&amp;rsquo;s criticism, these are spot on. However, strictyaml fixes this by cutting out those parts of the spec, leaving something that is actually simpler than HJSON.</description>
    </item>
    
    <item>
      <title>Why not use INI files?</title>
      <link>http://hitchdev.com/strictyaml/why-not/ini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/ini/</guid>
      <description>INI is a very old and quite readable configuration format. Unfortunately it suffers from two major problems:
 Different parsers will operate in subtly different ways that can lead to often obscure bugs regarding the way whitespace is used, case sensitivity, comments and escape characters. It doesn&amp;rsquo;t let you represent hierarchical data.  In a way, TOML</description>
    </item>
    
    <item>
      <title>Why not use JSON Schema for validation?</title>
      <link>http://hitchdev.com/strictyaml/why-not/json-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/json-schema/</guid>
      <description>JSON schema can also be used to validate YAML. This presumes that you might want to use jsonschema and pyyaml/ruamel.yaml together.
[ TODO Flesh out ]
 Line numbers Simpler errors in StrictYAML StrictYAML is a more flexible schema Turing incompleteness / inflexibility  </description>
    </item>
    
    <item>
      <title>Why not use SDLang?</title>
      <link>http://hitchdev.com/strictyaml/why-not/sdlang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/sdlang/</guid>
      <description>SDLang or &amp;ldquo;simple declarative language&amp;rdquo; is a proposed configuration language with an XML-like structure inspired by C.
Example:
// This is a node with a single string value title &amp;quot;Hello, World&amp;quot; // Multiple values are supported, too bookmarks 12 15 188 1234 // Nodes can have attributes author &amp;quot;Peter Parker&amp;quot; email=&amp;quot;peter@example.org&amp;quot; active=true // Nodes can be arbitrarily nested contents { section &amp;quot;First section&amp;quot; { paragraph &amp;quot;This is the first paragraph&amp;quot; paragraph &amp;quot;This is the second paragraph&amp;quot; } } // Anonymous nodes are supported &amp;quot;This text is the value of an anonymous node!</description>
    </item>
    
    <item>
      <title>Why not use TOML?</title>
      <link>http://hitchdev.com/strictyaml/why-not/toml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/toml/</guid>
      <description>TOML is a redesigned configuration language that&amp;rsquo;s essentially an extended version of INI which allows the expression of both hierarchical and typed data.
TOML&amp;rsquo;s main criticism of YAML is spot on::
TOML aims for simplicity, a goal which is not apparent in the YAML specification.
StrictYAML&amp;rsquo;s cut down version of the YAML specification however - with implicit typing, node anchors/references and flow style cut out, ends up being simpler than TOML.</description>
    </item>
    
    <item>
      <title>Why not use XML for configuration or DSLs?</title>
      <link>http://hitchdev.com/strictyaml/why-not/xml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/xml/</guid>
      <description>XML suffers from overcomplication much like vanilla YAML does - although to an ever greater degree, thanks to the committee driven design. Doctypes and namespaces are horrendous additions to the language, for instance. XML is not only not really human readable (beyond a very basic subset of the language), it&amp;rsquo;s often barely programmer readable despite being less expressive than most turing complete languages. It&amp;rsquo;s a flagrant violation of the rule of least power.</description>
    </item>
    
    <item>
      <title>Why not use kwalify with standard YAML to validate my YAML?</title>
      <link>http://hitchdev.com/strictyaml/why-not/pykwalify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/pykwalify/</guid>
      <description>Kwalify is a schema validation language that is written in YAML.
It is a descriptive schema language suitable for validating simple YAML.
Kwalify compiles to the strictyaml equivalent but is able to do less. You cannot, for example:
 Plug generated lists that come from outside of the spec (e.g. a list of country code from pycountry). Validate parts of the schema which can be either one thing or another - e.</description>
    </item>
    
    <item>
      <title>Why not use python&#39;s schema library for validation?</title>
      <link>http://hitchdev.com/strictyaml/why-not/python-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/python-schema/</guid>
      <description>Python&amp;rsquo;s &amp;lsquo;schema&amp;rsquo; (as well as similar libraries) can also be used to validate the structure of objects. Validating YAML is even cited as a reason on their README.
Problems:
 Line numbers and code snippets not reported on errors. YAML&amp;rsquo;s implicit typing will still ruin validation. Roundtripping is much less straightforward.  [ TODO flesh out ]</description>
    </item>
    
    <item>
      <title>Why not use the YAML 2.0 standard? - we don&#39;t need a new standard!</title>
      <link>http://hitchdev.com/strictyaml/why-not/ordinary-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/ordinary-yaml/</guid>
      <description>StrictYAML is composed of two parts:
 A new YAML specification which parses a restricted subset of the YAML 2.0 specification and only parse to ordered dict, list or string. An optional validator (which will, as requested, validate and cast parse some of those scalar string values to ints, floats, datetimes, etc.).  Note that StrictYAML is not a new standard. If you have a syntax highlighter or editor or anything else that recognizes or reads YAML it will recognize StrictYAML in the same way.</description>
    </item>
    
    <item>
      <title>Why shouldn&#39;t I just use python code for configuration?</title>
      <link>http://hitchdev.com/strictyaml/why-not/turing-complete-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://hitchdev.com/strictyaml/why-not/turing-complete-code/</guid>
      <description>This isn&amp;rsquo;t uncommon and can often seem like a nice, simple solution although using a turing complete language for configuration will often have nasty side effects.
Why does using YAML (or indeed, any configuration language) avoid this? Because they are less powerful languages than python.
While this may not intrinsically seem like a good thing (more power seems better at first glance), it isn&amp;rsquo;t:
 We need less powerful languages. Rule of least power (wikipedia).</description>
    </item>
    
  </channel>
</rss>
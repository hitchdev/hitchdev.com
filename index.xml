<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HitchDev</title>
    <link>https://hitchdev.com/</link>
    <description>Recent content on HitchDev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (C) 2018</copyright>
    
	<atom:link href="https://hitchdev.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hitchdev.com/principles/code-quality/naming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/principles/code-quality/naming/</guid>
      <description> title: Clear naming Naming is applied in various different contexts that apply to code:
 Variables Methods Classes Module names Project names  These principles apply to all of them.
There are typically three problems which lead to unclear naming:
 Ambiguous names Undefined names Misleading metaphors  Example principle conflicts:
 Write the least code possible - short names mean writing less code.  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hitchdev.com/strictyaml/new-faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/new-faq/</guid>
      <description>docs/why/features-removed.rst
docs/what-is-yaml.rst
docs/why/care-about-yaml.rst
docs/when/validators.rst
docs/why-not/ordinary-yaml.rst
docs/why-not/syntax-typing.rst
docs/why/implicit-typing-disallowed.rst
docs/why/binary-data-disallowed.rst
docs/why/explicit-tags-disallowed.rst
docs/why/node-anchors-and-references-disallowed.rst
docs/why/flow-style-disallowed.rst
docs/why-not/duplicate-keys-disallowed.rst
docs/why-not/ini.rst
docs/why-not/turing-complete-code.rst
docs/why-not/xml.rst
docs/why-not/json.rst
docs/why-not/toml.rst
docs/why-not/hocon.rst
docs/why-not/hjson.rst
docs/why-not/json5.rst
docs/why-not/sdlang.rst
docs/why-not/pykwalify.rst
docs/why-not/disagree.rst</description>
    </item>
    
    <item>
      <title>Abort a story with ctrl-C</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/aborting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/aborting/</guid>
      <description>When an in-progress story is hit with any of the following termination signals:
 SIGTERM SIGINT SIGQUIT SIGHUP  Then it triggers the tear_down method of the engine.
In practical terms this means that if you are running a series of stories, Ctrl-C should halt current execution, run tear_down and then not run any more stories.
example.story:
Createfiles:steps:-PauseforeverShouldneverrun:steps:-Shouldnothappen engine.py:
from hitchstory import BaseEngine from code_that_does_things import reticulate_splines import psutil class Engine(BaseEngine): def pause_forever(self): psutil.</description>
    </item>
    
    <item>
      <title>Arguments to steps</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/steps-and-step-arguments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/steps-and-step-arguments/</guid>
      <description>Arguments are fed to steps in a way that is largely consistent with how python methods work:
 Named arguments (e.g. &amp;ldquo;How many times&amp;rdquo;) are put in equivalent named variables (e.g. &amp;ldquo;how_many_times&amp;rdquo;). If the method has **kwargs then the key names of kwargs will match the named arguments exactly (i.e. no underscores).  engine.py:
from code_that_does_things import * from strictyaml import Int, Str, Bool from hitchstory import BaseEngine, validate class Engine(BaseEngine): def fill_form(self, **kwargs): for name, content in kwargs.</description>
    </item>
    
    <item>
      <title>Boolean (Bool)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/boolean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/boolean/</guid>
      <description>Boolean values can be parsed using a Bool validator.
It case-insensitively interprets &amp;ldquo;yes&amp;rdquo;, &amp;ldquo;true&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;on&amp;rdquo; as &amp;ldquo;True&amp;rdquo;, &amp;ldquo;y&amp;rdquo; and their opposites as False.
Different values will trigger a validation error.
When updating boolean values on a YAML object with True or False, the roundtripped string version is set to &amp;ldquo;yes&amp;rdquo; and &amp;ldquo;no&amp;rdquo;.
To have your boolean values updated to a different yes/no string, update with a string instead - e.</description>
    </item>
    
    <item>
      <title>Build a YAML document from scratch in code</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/build-yaml-document/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/build-yaml-document/</guid>
      <description>Experimental
This feature is in alpha. The API may change on a minor version increment.
 YAML documents can be built from dicts and lists of scalar values.
from ensure import Ensure from strictyaml import as_document from collections import OrderedDict # Can also use regular dict if an arbitrary ordering is ok yaml = as_document(OrderedDict( [(u&amp;#34;â&amp;#34;, True), (&amp;#34;b&amp;#34;, &amp;#34;hâllo&amp;#34;), (&amp;#34;c&amp;#34;, [1, 2, 3])] )) Then dump:
print(yaml.as_yaml())â:yesb:hâlloc:-1-2-3 Start line:
Ensure(yaml.start_line).equals(1) Executable specification</description>
    </item>
    
    <item>
      <title>Code quality principles</title>
      <link>https://hitchdev.com/principles/code-quality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/principles/code-quality/</guid>
      <description>Improved code quality is about reduced code maintenance costs. Code quality consideration is not a religious exercise, it is a budgeting exercise.
All of the principles here are important but they ought to be applied on a cost/benefit basis. They are all trade offs. There is sometimes a right answer (when improving code quality incurs a very small cost, you should always do it). There is sometimes no right answer.</description>
    </item>
    
    <item>
      <title>Commit messages and their meanings</title>
      <link>https://hitchdev.com/principles/commits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/principles/commits/</guid>
      <description>Each commit message takes the form TYPE : Message.
These messages are, in a sense, alpha. They take effect on March 1st, 2018:
TOOLING Changes to the tooling code. No changes to actual code of the project.
Changes to project code : no
DOCS Changes to documentation page or documentation template.
Changes to project code : no
STORY Refactoring of an existing story, its metadata, names, etc.
Changes to project code : no</description>
    </item>
    
    <item>
      <title>Compound StrictYAML Validators</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/</guid>
      <description> Using a YAML object of a parsed mapping Sequence/list validator (Seq) Sequences of unique items (UniqueSeq) Mapping with defined keys and a custom key validator (Map) Fixed length sequences (FixedSeq) Mappings with arbitrary key names (MapPattern) Mappings with defined keys (Map) Validating optional keys in mappings (Map)  </description>
    </item>
    
    <item>
      <title>Continue on failure when playing multiple stories</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/continue-on-failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/continue-on-failure/</guid>
      <description>By default whenever stories are played in sequence, they stop when the first failure is encountered.
However, if your stories take a long time to run you may wish to continue after the first failure.
example1.story:
ACreatefile:steps:-CreatefileBCreatefile:steps:-Fail example2.story:
CCreatefileathirdtime:steps:-Createfilefrom hitchstory import StoryCollection, BaseEngine from pathquery import pathquery class Engine(BaseEngine): def create_file(self, filename=&amp;#34;step1.txt&amp;#34;, content=&amp;#34;example&amp;#34;): with open(filename, &amp;#39;w&amp;#39;) as handle: handle.write(content) def fail(self): raise Exception(&amp;#34;Error&amp;#34;) Stop on failure is default behavior:
StoryCollection( pathquery(&amp;#34;.</description>
    </item>
    
    <item>
      <title>Datetimes (Datetime)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/datetime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/datetime/</guid>
      <description>Datetime validator parses using the python-dateutil library and returns a python datetime object.
Example yaml_snippet:
date:2016-10-22datetime1:2016-10-22T14:23:12+00:00datetime2:2016-10-22T14:23:12Zdatetime3:20161022T142312Zfrom strictyaml import Map, Datetime, YAMLValidationError, load from datetime import datetime from dateutil.tz.tz import tzutc from ensure import Ensure schema = Map({ &amp;#34;date&amp;#34;: Datetime(), &amp;#34;datetime1&amp;#34;: Datetime(), &amp;#34;datetime2&amp;#34;: Datetime(), &amp;#34;datetime3&amp;#34;: Datetime(), }) Each of the four datetimes are valid and parsed:
Ensure(load(yaml_snippet, schema)).equals({ &amp;#34;date&amp;#34;: datetime(2016, 10, 22, 0, 0), &amp;#34;datetime1&amp;#34;: datetime(2016, 10, 22, 14, 23, 12, tzinfo=tzutc()), &amp;#34;datetime2&amp;#34;: datetime(2016, 10, 22, 14, 23, 12, tzinfo=tzutc()), &amp;#34;datetime3&amp;#34;: datetime(2016, 10, 22, 14, 23, 12, tzinfo=tzutc()), }) .</description>
    </item>
    
    <item>
      <title>Decimal numbers (Decimal)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/decimal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/decimal/</guid>
      <description>StrictYAML parses to a YAML object representing a decimal, not the value directly to give you more flexibility and control over what you can do with the YAML.
This is what that can object can do - in many cases if parsed as a decimal, it will behave in the same way.
To get a python decimal.Decimal object, use .data.
Parsing and validating as a Decimal is best for values which require precision, like prices.</description>
    </item>
    
    <item>
      <title>Declarative User Stories</title>
      <link>https://hitchdev.com/hitchstory/why/declarative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/declarative/</guid>
      <description>HitchStory StoryFiles are declarative and not turing complete.
At their core, they essentially just contain marked up data - a set of preconditions (in &amp;lsquo;given&amp;rsquo;), a set of steps and arguments and the ability to parameterize the preconditions, step arguments and inherit one story from another.
No loops. No if statements. Deliberately turing incomplete.
Using a less powerful language to write tests in sounds counter-intuitive. Surely you want as much power as possible when writing tests so you can do as much as possible?</description>
    </item>
    
    <item>
      <title>Design Justifications</title>
      <link>https://hitchdev.com/strictyaml/why/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/</guid>
      <description>StrictYAML is the result of some carefully considered, although controversial design decisions. These are justified here.
 What is wrong with explicit tags? What is wrong with explicit syntax typing in a readable configuration language? What is wrong with implicit typing? What is wrong with flow style YAML? Why does StrictYAML only parse from strings and not files? What is wrong with duplicate keys? Why does StrictYAML not parse direct representations of python objects?</description>
    </item>
    
    <item>
      <title>Differences to Gherkin</title>
      <link>https://hitchdev.com/hitchstory/why-not/gherkin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why-not/gherkin/</guid>
      <description>HitchStory and Gherkin are both DSLs for writing user stories that can double as acceptance tests, but they have different philosophies and approach.
Gherkin scenarios emphasize the following values:
 The use of English to facilitate customer collaboration. Showing information that is &amp;ldquo;interesting to the business&amp;rdquo;.  Here are some examples.
From the Cucumber website:
Scenario: Buy last coffee Given there are 1 coffees left in the machine And I have deposited 1$ When I press the coffee button Then I should be served a coffee Hitch scenarios, by contrast, emphasizes the following values:</description>
    </item>
    
    <item>
      <title>Dirty load</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/loading-dirty-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/loading-dirty-yaml/</guid>
      <description>StrictYAML refuses to parse flow style and node anchors by default, but since there have since been some requests to parse flow style, this now allowed with the &amp;ldquo;dirty_load&amp;rdquo; method.
from strictyaml import Map, Int, MapPattern, Seq, Str, Any, dirty_load schema = Map({&amp;#34;x&amp;#34;: Map({&amp;#34;a&amp;#34;: Any(), &amp;#34;b&amp;#34;: Any(), &amp;#34;c&amp;#34;: Any()}), &amp;#34;y&amp;#34;: MapPattern(Str(), Str()), &amp;#34;z&amp;#34;: Seq(Str())}) Flow style mapping:
x:{a:1,b:2,c:3}y:{}z:[]assert dirty_load(yaml_snippet, schema, allow_flow_style=True) == {&amp;#34;x&amp;#34;: {&amp;#34;a&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;2&amp;#34;, &amp;#34;c&amp;#34;: &amp;#34;3&amp;#34;}, &amp;#34;y&amp;#34;: {}, &amp;#34;z&amp;#34;: []} Executable specification</description>
    </item>
    
    <item>
      <title>Disallowed YAML</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/disallowed-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/disallowed-yaml/</guid>
      <description>StrictYAML parses an opinionated subset of the YAML specification which refuses to parse features which are otherwise valid in standard YAML.
For an explanation as to why these features are stripped out of StrictYAML, see the FAQ.
Disallowed YAML features raise Disallowed exceptions while syntactically invalid YAML raises ScannerError or ComposerError.
Every error inherits from YAMLError.
from strictyaml import Map, Int, Any, load from strictyaml import TagTokenDisallowed, FlowMappingDisallowed, AnchorTokenDisallowed schema = Map({&amp;#34;x&amp;#34;: Map({&amp;#34;a&amp;#34;: Any(), &amp;#34;b&amp;#34;: Any(), &amp;#34;c&amp;#34;: Any()})}) Tag tokens:</description>
    </item>
    
    <item>
      <title>Discussion of requested feature inheritance in Cucumber</title>
      <link>https://hitchdev.com/hitchstory/why/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/inheritance/</guid>
      <description>Inheritance is a feature which was deliberately left out of Cucumber:
https://stackoverflow.com/questions/41872376/can-a-cucumber-feature-file-inherit-from-a-parent-feature-file
However, it was deliberately added to hitchstory.</description>
    </item>
    
    <item>
      <title>Duplicate keys</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/duplicate-keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/duplicate-keys/</guid>
      <description>Duplicate keys are allowed in regular YAML - as parsed by pyyaml, ruamel.yaml and poyo:
Not only is it unclear whether x should be &amp;ldquo;cow&amp;rdquo; or &amp;ldquo;bull&amp;rdquo; (the parser will decide &amp;lsquo;bull&amp;rsquo;, but did you know that?), if there are 200 lines between x: cow and x: bull, a user might very likely change the first x and erroneously believe that the resulting value of x has been changed - when it has not.</description>
    </item>
    
    <item>
      <title>Either/or schema validation of two equally valid different kinds of YAML</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/either-or-validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/either-or-validation/</guid>
      <description>StrictYAML can be directed to parse two different elements or blocks of YAML.
If the first thing does not parse correctly, it attempts to parse the second. If the second does not parse correctly, it raises an exception.
from strictyaml import Map, Bool, Int, YAMLValidationError, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Bool() | Int()}) Boolean first choice true:
a:yesEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: True}) Boolean first choice false:
a:noEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: False}) Int second choice:</description>
    </item>
    
    <item>
      <title>Element should not be on page</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/disappearing-element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/disappearing-element/</guid>
      <description>The following example shows a &amp;lsquo;loading overlay&amp;rsquo; element which must disappear before the page can be interacted with.
Using .should_not_be_on_page(after=seconds) selenium director can wait for the absence of the element and, if it is still there after a timeout, raise an exception.
This is also useful for writing stories to invoke bugs that accidentally display elements that shouldn&amp;rsquo;t be there.
HTML:
index.html:
&amp;lt;div class=&amp;#34;form-login&amp;#34;&amp;gt; &amp;lt;h4&amp;gt;Dashboard&amp;lt;/h4&amp;gt; &amp;lt;p id=&amp;#34;id_dashboard_message&amp;#34;&amp;gt;hello!&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; Javascript embedded in above HTML:</description>
    </item>
    
    <item>
      <title>Email and URL validators</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/email-and-url/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/email-and-url/</guid>
      <description>StrictYAML can validate emails (using a simplified regex) and URLs.
from strictyaml import Email, Url, Map, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Email(), &amp;#34;b&amp;#34;: Url()}) Parsed:
a:billg@microsoft.comb:http://www.google.com/Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;billg@microsoft.com&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;http://www.google.com/&amp;#34;}) Exception:
a:notanemailb:notaurlload(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: when expecting an email address found non-matching string in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: notanemail ^ (line: 1) Executable specification
Page automatically generated from email-url.story.
 </description>
    </item>
    
    <item>
      <title>Empty key validation</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/empty/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/empty/</guid>
      <description>Sometimes you may wish to not specify a value or specify that it does not exist.
Using StrictYAML you can accept this as a valid value and have it parsed to one of three things - None, {} (empty dict), or [] (empty list).
Example yaml_snippet:
a:from strictyaml import Map, Str, Enum, EmptyNone, EmptyDict, EmptyList, load from ensure import Ensure EmptyNone with empty value:
Ensure(load(yaml_snippet, Map({&amp;#34;a&amp;#34;: EmptyNone() | Enum([&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;,])}))).equals({&amp;#34;a&amp;#34;: None}) EmptyDict:</description>
    </item>
    
    <item>
      <title>Enumerated scalars (Enum)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/enum/</guid>
      <description>StrictYAML allows you to ensure that a scalar value can only be one of a set number of items.
It will throw an exception if any strings not in the list are found.
from strictyaml import Map, Enum, MapPattern, YAMLValidationError, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Enum([&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;])}) Valid because it contains &amp;lsquo;A&amp;rsquo;:
a:AEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;A&amp;#34;}) Valid because it contains &amp;lsquo;B&amp;rsquo;:
a:BEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;B&amp;#34;}) Valid because it contains &amp;lsquo;C&amp;rsquo;:</description>
    </item>
    
    <item>
      <title>Extra story metadata - e.g. adding JIRA ticket numbers to stories</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/metadata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/metadata/</guid>
      <description>Each and every story is related to issues on issue trackers, specialist documentation, people, external resources and much more.
The best place to document this additional metadata is not buried in word documents on company wikis but within the story itself.
What kind of metadata you add to stories is up to you - simply add the names of the properties you want to add in the info parameter of your engine InfoDefinition and specify the structure of the metadata using StrictYAML validators inside the InfoProperty object.</description>
    </item>
    
    <item>
      <title>Fixed length sequences (FixedSeq)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/fixed-length-sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/fixed-length-sequences/</guid>
      <description>Sequences of fixed length can be validated with a series of different (or the same) types.
from strictyaml import FixedSeq, Str, Map, Int, Float, YAMLValidationError, load from ensure import Ensure schema = FixedSeq([Int(), Map({&amp;#34;x&amp;#34;: Str()}), Float()]) Equivalent list:
-1-x:5-2.5Ensure(load(yaml_snippet, schema)).equals([1, {&amp;#34;x&amp;#34;: &amp;#34;5&amp;#34;}, 2.5, ]) Invalid list 1:
a:1b:2c:3load(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: when expecting a sequence of 3 elements in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: &amp;#39;1&amp;#39; ^ (line: 1) found a mapping in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 3, column 1: c: &amp;#39;3&amp;#39; ^ (line: 3) Invalid list 2:</description>
    </item>
    
    <item>
      <title>Flaky Tests</title>
      <link>https://hitchdev.com/hitchstory/why/flaky-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/flaky-tests/</guid>
      <description>Flaky tests are tests which will do not pass or fail consistently.
Higher level tests suffer more from flakiness than low level tests, although this tends to be only because high level tests are testing more code.
The probability of flakiness increases with the amount of code being tested.
How to deal with flakiness? Flakiness in any test should be considered a bug to be fixed.
It should not ever, ever just be considered &amp;ldquo;just a fact of life&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Flaky story detection</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/flaky-story-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/flaky-story-detection/</guid>
      <description>Dealing with flaky stories, especially with higher level integration tests is a constant battle.
These examples show how flaky stories can be detected by rerunning stories several times and checking that the result is the same. This kind of regression testing can be usefully run separately from normal regression testing in order to get separate feedback about problematic tests in a &amp;lsquo;flake&amp;rsquo; report.
This cannot detect all kinds of flakiness, but it can be effective at detecting flakiness caused by, for example:</description>
    </item>
    
    <item>
      <title>Floating point numbers (Float)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/float/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/float/</guid>
      <description>StrictYAML parses to a YAML object representing a decimal - e.g. YAML(1.0000000000000001)
To get a python float literal, use .data.
Parsing and validating as a Decimal is best for values which require precision, but float is better for values for which precision is not required.
Example yaml_snippet:
a:1.00000000000000000001b:5.4135from strictyaml import Map, Float, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Float(), &amp;#34;b&amp;#34;: Float()}) Use .data to get float type:
Ensure(type(load(yaml_snippet, schema)[&amp;#34;a&amp;#34;].</description>
    </item>
    
    <item>
      <title>Generate documentation from stories</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/generate-documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/generate-documentation/</guid>
      <description>While hitchstory YAML stories are designed to be as readable as possible while still remaining terse and easy to maintain, it is not readable user documentation and is not intended for use by stakeholders to understand how a system operates.
However, stakeholders do need documentation and user stories form an excellent base to build documentation from.
Using hitchstory story and story list objects you can generate documentation using a simple templating language.</description>
    </item>
    
    <item>
      <title>Get line numbers of YAML elements</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/what-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/what-line/</guid>
      <description>Line numbers, the text of an item and text of surrounding lines can be grabbed from returned YAML objects - using .start_line, .end_line, lines(), lines_before(x) and lines_after(x).
Example yaml_snippet:
y:p# Some commenta:| x# Another commentb:yc:ad:bfrom strictyaml import Map, Str, YAMLValidationError, load from ensure import Ensure schema = Map({&amp;#34;y&amp;#34;: Str(), &amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Str(), &amp;#34;c&amp;#34;: Str(), &amp;#34;d&amp;#34;: Str()}) snippet = load(yaml_snippet, schema) If there is preceding comment for an item the start line includes it:</description>
    </item>
    
    <item>
      <title>Given preconditions</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/given/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/given/</guid>
      <description>Stories optionally start with a set of preconditions.
Hitchstory lets you define these &amp;lsquo;given&amp;rsquo; preconditions using YAML mapping and access them in the story by using self.given as you would a dict - e.g. self.given[&amp;lsquo;property name&amp;rsquo;].
The given property names need to first be specified in the engine using GivenDefinition and GivenPropery - optionally with a StrictYAML schema.
example.story:
Createfiles:given:thing:content:thingsListofthings:-thingone-thingtwoscalarthing:35steps:-Createfile engine.py:
from hitchstory import BaseEngine, GivenDefinition, GivenProperty from strictyaml import Str, Map, Seq, Int, MapPattern def output(contents): with open(&amp;#34;output.</description>
    </item>
    
    <item>
      <title>Gradual typing of story steps</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/gradual-typing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/gradual-typing/</guid>
      <description>In order to speed up prototyping and development of a story suite, the structure of your YAML data specified in preconditions, parameters and step arguments need not be specified in advance.
All data that is parsed without a validator is parsed either as a dict, list or string, as per the StrictYAML spec.
When your story suite matures and the structure of your story files has solidified, you can specify validators that fail fast when YAML snippets with an invalid structure are used.</description>
    </item>
    
    <item>
      <title>Handling failing tests</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/failing-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/failing-tests/</guid>
      <description>By default, a failing story will show:
 A snippet of the YAML where the story failed with the failing step highlighted. A stack trace from engine.py where the exception was raised.  example.story:
Failingstory:steps:-Passingstep-Failingstep-Notexecutedstep engine.py:
from hitchstory import BaseEngine, no_stacktrace_for, Failure from code_that_does_things import raise_example_exception, output, ExampleException class Engine(BaseEngine): def passing_step(self): pass def failing_step(self): raise_example_exception(&amp;#34;Towel not located&amp;#34;) @no_stacktrace_for(ExampleException) def failing_step_without_stacktrace(self): raise_example_exception(&amp;#34;Expected exception&amp;#34;) def raise_special_failure_exception(self): raise Failure(&amp;#34;Special failure exception - no stacktrace printed!</description>
    </item>
    
    <item>
      <title>Hiding stacktraces for expected exceptions</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/expected-exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/expected-exceptions/</guid>
      <description>For common expected failures where you do not want to see the whole stacktrace, apply the &amp;ldquo;@no_stacktrace_for&amp;rdquo; decorator.
example.story:
Failingstory:steps:-Failingstepwithoutstacktrace engine.py:
from hitchstory import BaseEngine, no_stacktrace_for, Failure from code_that_does_things import raise_example_exception, output, ExampleException class Engine(BaseEngine): def passing_step(self): pass def failing_step(self): raise_example_exception(&amp;#34;Towel not located&amp;#34;) @no_stacktrace_for(ExampleException) def failing_step_without_stacktrace(self): raise_example_exception(&amp;#34;Expected exception&amp;#34;) def raise_special_failure_exception(self): raise Failure(&amp;#34;Special failure exception - no stacktrace printed!&amp;#34;) def step_that_will_not_run(self): pass def on_failure(self, result): pass def not_executed_step(self): passfrom hitchstory import StoryCollection from engine import Engine from pathquery import pathquery story_collection = StoryCollection(pathquery(&amp;#34;.</description>
    </item>
    
    <item>
      <title>HitchDev</title>
      <link>https://hitchdev.com/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/</guid>
      <description>HitchDev is a group of self contained, heavily dogfooded python libraries - mainly used for setting up and running dev and test environments:
Current fully documented projects:
 StrictYAML &amp;ndash; YAML parser and validator that parses a restricted subset of the YAML spec. HitchStory &amp;ndash; StrictYAML based BDD framework. SeleniumDirector &amp;ndash; declare page (CSS/ID/xpath/etc.) selectors and give them readable names which can be used in readable python code or tests.  Projects that will be documented soon:</description>
    </item>
    
    <item>
      <title>HitchStory</title>
      <link>https://hitchdev.com/hitchstory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/</guid>
      <description>HitchStory is a python 3 library for building and running BDD-style executable specifications.
Unlike most other BDD tools which use, e.g. Gherkin the specification is written with a StrictYAML dialect.
Example example.story:
Login:given:website:/login# preconditionssteps:-Fillform:username:AzureDiamond# parameterized stepspassword:hunter2-Click:loginSendemail:about:Corefunctionalityofapp.basedon:login# inherits from and continues from test abovesteps:-Click:newemail-Fillform:to:Cthon98@aol.comcontents:| # long form textHeyguys,IthinkIgothacked!-Click:sendemail-Emailwassent engine.py:
from hitchstory import BaseEngine, GivenDefinition, GivenProperty from mockemailchecker import email_was_sent from mockselenium import Webdriver from strictyaml import Str class Engine(BaseEngine): given_definition = GivenDefinition( website=GivenProperty(Str()), ) def set_up(self): self.</description>
    </item>
    
    <item>
      <title>HitchStory Philosophy</title>
      <link>https://hitchdev.com/hitchstory/why/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/</guid>
      <description>HitchStory is a BDD/ATDD framework for writing executable stories which follows a set of 10 principles.
These principles both differ slightly from BDD principles and go beyond them.
Story Principles #1 Stories should follow the &amp;ldquo;screenplay principle&amp;rdquo; - if it is visible to the user, it should be reflected in the story.
Note that this differs from the principle of BDD that &amp;ldquo;if it is interesting to the business&amp;rdquo; it should be reflected in the story.</description>
    </item>
    
    <item>
      <title>How to...</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/</guid>
      <description> Get line numbers of YAML elements Revalidate an already validated document Build a YAML document from scratch in code Reading in YAML, editing it and writing it back out Labeling exceptions Merge YAML documents Either/or schema validation of two equally valid different kinds of YAML Parsing YAML without a schema  </description>
    </item>
    
    <item>
      <title>I am perfectly happy with py.test (or other unit testing framework). Why should I use hitchstory?</title>
      <link>https://hitchdev.com/hitchstory/why/unit-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/unit-tests/</guid>
      <description>Ultimately it boils down to two programming principles which hitchstory provides &amp;lsquo;rails&amp;rsquo; to guide you:
 The rule of least power Separation of concerns  Hitchstory stories describe a sequence of events which describe either a user or a user-system interacting with your code. This can be used to describe the functioning of any software system. It is not necessary** to use turing complete code to describe a sequence of events, therefore, according to the rule of least power, you shouldn&amp;rsquo;t use turing complete code to do it.</description>
    </item>
    
    <item>
      <title>I see given but where is when and then?</title>
      <link>https://hitchdev.com/hitchstory/why/given-when-then/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/given-when-then/</guid>
      <description>You can certainly write user stories using when and then like so:
Given:Ihave:redboxSteps:-WhenIclick:theredbutton-Thenitgoeskaboom However, hitchstory does not require this, and it is not generally encouraged because, as with code, terseness and ease of editing is of primary importance and this languge is designed for use primarily by programmers.
Writing the story like this is terser and no less clear:
given:box:redsteps:-click:redbutton-goeskaboom Where stakeholders wish to read documentation that is longer form and more flowing, the latter can still be used to generate it.</description>
    </item>
    
    <item>
      <title>Inherit one story from another</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/inheritance/</guid>
      <description>You can break most software down into a series of individual linear behavioral stories.
However, software stories naturally branch. In order to send an email or delete an email you must first always log in.
While it would be possible to write out each individual story for every possible branch, this would result in a story suite that is WET instead of DRY and that creates a maintenance headache.
Story inheritance allows you to base stories on other stories.</description>
    </item>
    
    <item>
      <title>Integers (Int)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/integer/</guid>
      <description>StrictYAML parses to a YAML object, not the value directly to give you more flexibility and control over what you can do with the YAML.
This is what that can object can do - in many cases if parsed as a integer, it will behave in the same way.
Example yaml_snippet:
a:1b:5from strictyaml import Map, Int, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Int(), &amp;#34;b&amp;#34;: Int()}) parsed = load(yaml_snippet, schema) Parsed correctly:</description>
    </item>
    
    <item>
      <title>Is HitchStory for writing &#34;human writable&#34; stories?</title>
      <link>https://hitchdev.com/hitchstory/why/human-writable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/human-writable/</guid>
      <description>No. Having &amp;ldquo;analysts&amp;rdquo; write stories instead of programmers is an explicit non-goal, unlike that of Cucumber.
It ought to be possible to write hitch stories with less training than is required to be a programmer since the language is conceptually simpler than turing complete programming languages.
However, it still would require some training to write and instincts that are generally only honed by programmers - e.g the instinct to DRY the code, the instinct to parameterize and to generalize are often not present among non-programmers.</description>
    </item>
    
    <item>
      <title>Is hitchstory a BDD language?</title>
      <link>https://hitchdev.com/hitchstory/why/bdd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/bdd/</guid>
      <description>Yes and no.
Primarily, BDD is about customer collaboration on writing stories. It does not have any technical requirements - simply jotting down an expected behavior on the back of a napkin with a customer is technically considered BDD, no matter what tools are used after that.
However, HitchStory can be used to make BDD easier for a number of reasons:
 The executable stories will be easier for non-programmers subject matter experts to read than turing complete code (e.</description>
    </item>
    
    <item>
      <title>Labeling exceptions</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/label-exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/label-exceptions/</guid>
      <description>When raising exceptions, you can add a label that will replace with whatever you want.
Example yaml_snippet:
a:1b:-1-2from strictyaml import Map, Int, load, YAMLValidationError Label myfilename:
load(yaml_snippet, Map({&amp;#34;a&amp;#34;: Int(), &amp;#34;b&amp;#34;: Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()})}), label=&amp;#34;myfilename&amp;#34;)strictyaml.exceptions.YAMLValidationError: when expecting a mapping in &amp;#34;myfilename&amp;#34;, line 2, column 1: b: ^ (line: 2) found a sequence in &amp;#34;myfilename&amp;#34;, line 4, column 1: - &amp;#39;2&amp;#39; ^ (line: 4) Executable specification
Page automatically generated from handle-exceptions.story.</description>
    </item>
    
    <item>
      <title>Mapping with defined keys and a custom key validator (Map)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-with-slug-keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-with-slug-keys/</guid>
      <description>Experimental
This feature is in alpha. The API may change on a minor version increment.
 A typical mapping except that the key values are determined by the value provided by the validator.
Example yaml_snippet:
Name:UnitedKingdomcountry-code:GBDIALCODE:+44officiallanguages:-English-Welshfrom collections import OrderedDict from strictyaml import Map, Str, Seq, load, ScalarValidator from ensure import Ensure # This example uses slugify from the &amp;#34;python-slugify&amp;#34; package from slugify import slugify class Slug(ScalarValidator): def validate_scalar(self, chunk): return slugify(unicode(chunk.</description>
    </item>
    
    <item>
      <title>Mappings with arbitrary key names (MapPattern)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/map-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/map-pattern/</guid>
      <description>When you do not wish to let the user define the key names in a mapping and and only specify what type the keys are, use a MapPattern.
When you wish to specify the exact key name, use the &amp;lsquo;Map&amp;rsquo; validator instead.
from strictyaml import MapPattern, Int, Str, YAMLValidationError, load from ensure import Ensure schema = MapPattern(Str(), Int()) Equivalence 1:
â:1b:2Ensure(load(yaml_snippet, schema)).equals({u&amp;#34;â&amp;#34;: 1, &amp;#34;b&amp;#34;: 2}) Equivalence 2:
a:1c:3Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1, &amp;#34;c&amp;#34;: 3}) Equivalence 3:</description>
    </item>
    
    <item>
      <title>Mappings with defined keys (Map)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/mapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/mapping/</guid>
      <description>Mappings of one value to another are represented by : in YAML and parsed as python dicts.
Using StrictYAML&amp;rsquo;s &amp;lsquo;Map&amp;rsquo; you can validate that a mapping contains the right keys and the right type of values.
Note: for mappings where you don&amp;rsquo;t know the exact names of the keys in advance but you do know the type, use MapPattern.
Example yaml_snippet:
â:1b:2c:3from collections import OrderedDict from strictyaml import Map, Int, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Int(), &amp;#34;b&amp;#34;: Int(), &amp;#34;c&amp;#34;: Int()}) schema_2 = Map({u&amp;#34;â&amp;#34;: Int(), &amp;#34;b&amp;#34;: Int(), &amp;#34;c&amp;#34;: Int()}) one key mapping:</description>
    </item>
    
    <item>
      <title>Merge YAML documents</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/merge-yaml-documents/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/merge-yaml-documents/</guid>
      <description>Loaded YAML can be combined and dumped with the comments intact.
from strictyaml import Map, MapPattern, Str, Seq, Int, load schema_1 = Map({ &amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()}), &amp;#34;c&amp;#34;: Seq(MapPattern(Str(), Str())), }) schema_2 = Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()}) yaml_1 = load(yaml_snippet_1, schema_1) yaml_2 = load(yaml_snippet_2, schema_2) yaml_1[&amp;#39;b&amp;#39;] = yaml_2print(yaml_1.as_yaml())# Some commenta:â# value comment# Another commentb:x:8# y is now 9y:9c:-a:1-b:2 Executable specification
Page automatically generated from merge-documents.story.
 </description>
    </item>
    
    <item>
      <title>Overlay - should_be_on_top</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/element-should-be-on-top/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/element-should-be-on-top/</guid>
      <description>This example demonstrates .should_be_on_top() which waits not only for an element to be present on the page (without display:none set), it will wait until no other element covers it.
should_be_on_top checks the dead center of the element to see if it is covered. If the middle is covered and the corners are not then it will still think that the element is covered.
HTML:
index.html:
&amp;lt;div class=&amp;#34;form-login&amp;#34;&amp;gt; &amp;lt;h4&amp;gt;Dashboard&amp;lt;/h4&amp;gt; &amp;lt;p id=&amp;#34;id_dashboard_message&amp;#34;&amp;gt;hello!&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; Javascript embedded in above HTML:</description>
    </item>
    
    <item>
      <title>Parsing YAML without a schema</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/without-a-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/without-a-schema/</guid>
      <description>When using strictyaml you do not have to specify a schema. If you do this, the validator &amp;ldquo;Any&amp;rdquo; is used which will accept any mapping and any list and any scalar values (which will always be interpreted as a string, unlike regular YAML).
This is the recommended approach when rapidly prototyping and the desired schema is fluid.
When your prototype code is parsing YAML that has a more fixed structure, we recommend that you &amp;lsquo;lock it down&amp;rsquo; with a schema.</description>
    </item>
    
    <item>
      <title>Parsing comma separated items (CommaSeparated)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/comma-separated/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/comma-separated/</guid>
      <description>Comma-separated values can be validated and parsed using the CommaSeparated validator.
Note that the space following the commas is stripped by default when parsed.
from strictyaml import CommaSeparated, Int, Str, Map, load from ensure import Ensure int_schema = Map({&amp;#34;a&amp;#34;: CommaSeparated(Int())}) str_schema = Map({&amp;#34;a&amp;#34;: CommaSeparated(Str())}) Parse as int:
a:1,2,3Ensure(load(yaml_snippet, int_schema)).equals({&amp;#34;a&amp;#34;: [1, 2, 3]}) Parse as string:
a:1,2,3Ensure(load(yaml_snippet, str_schema)).equals({&amp;#34;a&amp;#34;: [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;]}) Invalid int comma separated sequence:
a:1,x,3load(yaml_snippet, int_schema)strictyaml.exceptions.YAMLValidationError: when expecting an integer in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 2, column 1: ^ (line: 2) found arbitrary text in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: 1, x, 3 ^ (line: 1) Executable specification</description>
    </item>
    
    <item>
      <title>Parsing strings (Str)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/string/</guid>
      <description>StrictYAML parses to a YAML object, not the value directly to give you more flexibility and control over what you can do with the YAML.
This is what that can object can do - in most cases if parsed as a string, it will behave in the same way.
Example yaml_snippet:
a:1b:yesc:âstringd:| multiline stringfrom strictyaml import Str, Map, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Str(), &amp;#34;c&amp;#34;: Str(), &amp;#34;d&amp;#34;: Str()}) parsed = load(yaml_snippet, schema) Parses correctly:</description>
    </item>
    
    <item>
      <title>Play multiple stories in sequence</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/play-multiple-stories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/play-multiple-stories/</guid>
      <description>Running multiple stories in sequence is necessary when you want to do a regression sweep to make sure nothing has broken.
By default hitchstory will stop when it sees its first failure. This behavior can be changed though.
Example base.story:
Basestory:given:randomvariable:somevalue example1.story:
Createfile:basedon:basestorysteps:-CreatefileCreatefileagain:basedon:basestorysteps:-Createfile example2.story:
Createfiles:basedon:basestorysteps:-Createfilefrom hitchstory import StoryCollection, BaseEngine, GivenDefinition, GivenProperty from pathquery import pathquery from ensure import Ensure class Engine(BaseEngine): given_definition=GivenDefinition( random_variable=GivenProperty() ) def create_file(self, filename=&amp;#34;step1.txt&amp;#34;, content=&amp;#34;example&amp;#34;): with open(filename, &amp;#39;w&amp;#39;) as handle: handle.</description>
    </item>
    
    <item>
      <title>Principles of HitchDev</title>
      <link>https://hitchdev.com/principles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/principles/</guid>
      <description>Documented principles of HitchDev:
 HitchDev Code Quality Principles HitchDev Project Commit Message Rules  </description>
    </item>
    
    <item>
      <title>Reading in YAML, editing it and writing it back out</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/roundtripping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/roundtripping/</guid>
      <description>Loaded YAML can be modified and dumped out again with comments preserved using .as_yaml().
Note that due to some bugs in the library (ruamel.yaml) underlying StrictYAML, while the data parsed should be precisely the same, the exact syntax (newlines, comment locations, etc.) may not be identical.
Example yaml_snippet:
# Some commenta:â# value comment# Another commentb:x:4y:5c:-a:1-b:2from strictyaml import Map, MapPattern, Str, Seq, Int, load from ensure import Ensure schema = Map({ &amp;#34;a&amp;#34;: Str(), &amp;#34;b&amp;#34;: Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Int()}), &amp;#34;c&amp;#34;: Seq(MapPattern(Str(), Str())), }) Commented:</description>
    </item>
    
    <item>
      <title>Restrictions</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/restrictions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/restrictions/</guid>
      <description> Disallowed YAML Duplicate keys Dirty load  </description>
    </item>
    
    <item>
      <title>Revalidate an already validated document</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/howto/revalidation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/howto/revalidation/</guid>
      <description>When parsing a YAML document you may wish to validate part of the document and then later on validate other sections within it.
This may be required because:
 One part of the document validation depends upon another (example here). It simplifies the code to apply different kinds of validation at different steps.  Example yaml_snippet:
capitals:UK:1Germany:2countries:-Germany-UKfrom strictyaml import Str, Int, Map, Seq, Any, load from ensure import Ensure overall_schema = Map({&amp;#34;capitals&amp;#34;: Any(), &amp;#34;countries&amp;#34;: Seq(Str())}) parsed = load(yaml_snippet, overall_schema) Reparse mapping:</description>
    </item>
    
    <item>
      <title>Running a single named story successfully</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/run-single-named-story/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/run-single-named-story/</guid>
      <description>How a story runs when it is successful - i.e. when no exception is raised during its run.
example.story:
Createfiles:steps:-Createfile-Createfile:step2.txt-Createfile:filename:step3.txtcontent:thirdstep engine.py:
from hitchstory import BaseEngine class Engine(BaseEngine): def create_file(self, file_name=&amp;#34;step1.txt&amp;#34;, content=&amp;#34;example&amp;#34;): with open(file_name, &amp;#39;w&amp;#39;) as handle: handle.write(content) def on_success(self): print(&amp;#34;splines reticulated&amp;#34;) with open(&amp;#34;ranstory.txt&amp;#34;, &amp;#39;w&amp;#39;) as handle: handle.write(self.story.name)from hitchstory import StoryCollection from pathquery import pathquery from engine import EngineStoryCollection(pathquery(&amp;#34;.&amp;#34;).ext(&amp;#34;story&amp;#34;), Engine()).named(&amp;#34;Create files&amp;#34;).play() Will output:
RUNNING Create files in /path/to/example.story ... splines reticulated SUCCESS in 0.</description>
    </item>
    
    <item>
      <title>Scalar StrictYAML Validators</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/</guid>
      <description> Validating strings with regexes (Regex) Parsing comma separated items (CommaSeparated) Datetimes (Datetime) Empty key validation Decimal numbers (Decimal) Boolean (Bool) Integers (Int) Enumerated scalars (Enum) Floating point numbers (Float) Email and URL validators Parsing strings (Str)  </description>
    </item>
    
    <item>
      <title>Screenplay Principle</title>
      <link>https://hitchdev.com/hitchstory/why/screenplay-principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/screenplay-principle/</guid>
      <description>You don&amp;rsquo;t tell your audience your story, you show them. You must learn to write a screenplay visually. Write what they will see and what they will hear.
 - http://www.screenwriting.info  An iron rule of screenplay writing is that you do not write what a character thinks. You must demonstrate via their actions and words what they think.
This parallels a similar problem with software specification:
 Overspecification - where a specification defines how a problem is to be achieved, rather than what problem is to be achieved.</description>
    </item>
    
    <item>
      <title>Selector for element inside iframe</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/iframe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/iframe/</guid>
      <description>If an element you are trying to use is inside an iframe, use &amp;ldquo;in iframe&amp;rdquo; in the list of elements to refer to an selector name that uniquely identifies the iframe.
HTML:
iframe.html:
&amp;lt;p id=&amp;#34;id_dashboard_message&amp;#34;&amp;gt;hello!&amp;lt;/a&amp;gt; index.html:
&amp;lt;div id=&amp;#34;id_login_page&amp;#34; class=&amp;#34;form-login&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;id_username&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;username&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;id_password&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;password&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;group-btn&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id_ok_button&amp;#34; href=&amp;#34;/dashboard.html&amp;#34; class=&amp;#34;btn btn-primary btn-md&amp;#34;&amp;gt;login &amp;lt;i class=&amp;#34;fa fa-sign-in&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; dashboard.</description>
    </item>
    
    <item>
      <title>Selectors using HTML contents</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/html-element-contents/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/html-element-contents/</guid>
      <description>This story demonstrates using the textual content of HTML elements to select them.
Either &amp;ldquo;text is&amp;rdquo; to match the text exactly or &amp;ldquo;text contains&amp;rdquo; to match partial text.
Use &amp;lsquo;which&amp;rsquo; to match a specific element when more than one matches.
HTML:
index.html:
&amp;lt;div class=&amp;#34;form-login&amp;#34;&amp;gt; &amp;lt;div&amp;gt;login&amp;lt;/div&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; class=&amp;#34;class_username form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;username&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; class=&amp;#34;class_password form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;password&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;group-btn&amp;#34;&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; class=&amp;#34;btn btn-primary btn-md&amp;#34;&amp;gt;not login &amp;lt;i class=&amp;#34;fa fa-sign-in&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;/dashboard.</description>
    </item>
    
    <item>
      <title>Selectors with HTML IDs</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/html-ids/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/html-ids/</guid>
      <description>This example demonstrates how to look for of HTML IDs to select and use HTML elements by using &amp;lsquo;id=class_name&amp;rsquo; or &amp;lsquo;id: class_name&amp;rsquo;.
This is often the ideal kind of selector to use if an element has an ID, since IDs tend to be relatively unchanging and the likelihood of accidentally selecting the wrong element is low.
If there is more than one element matching a ID (shouldn&amp;rsquo;t be common since that&amp;rsquo;s a violation of HTML semantics, but it still happens!</description>
    </item>
    
    <item>
      <title>Selectors with HTML classes</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/html-classes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/html-classes/</guid>
      <description>This example demonstrates how to look for the presence of HTML classes to select and use HTML elements by using &amp;lsquo;class=class_name&amp;rsquo; or &amp;lsquo;class: class_name&amp;rsquo;.
If there is more than one element matching a class (common, since that&amp;rsquo;s how classes are supposed to be used), the element to use can be specified using &amp;lsquo;which: [ number ]&amp;rsquo; or which: last.
HTML:
index.html:
&amp;lt;div class=&amp;#34;class_this_is_a_login_page form-login&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; class=&amp;#34;class_username form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;username&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; class=&amp;#34;class_password form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;password&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;group-btn&amp;#34;&amp;gt; &amp;lt;a href=&amp;#34;/dashboard.</description>
    </item>
    
    <item>
      <title>SeleniumDirector</title>
      <link>https://hitchdev.com/seleniumdirector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/</guid>
      <description>SeleniumDirector is a python 3 library that makes it straightforward to write easily maintainable python code to interact with websites in a non-brittle way using the screenplay pattern with selenium.
Seleniumdirector reads YAML &amp;ldquo;selector&amp;rdquo; files which associate readable labels with complex selectors - i.e. class name selectors, id selectors, attribute selectors, text and xpath.
Separating the &amp;ldquo;element selection&amp;rdquo; concern from element interaction allows for simpler, more straightforward and more readable code.</description>
    </item>
    
    <item>
      <title>Sequence/list validator (Seq)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/sequences/</guid>
      <description>Sequences in YAML are denoted by a series of dashes (&amp;lsquo;-&amp;rsquo;) and parsed as a list in python.
Validating sequences of a particular type can be done with the Seq validator, specifying the type.
See also UniqueSeq and FixedSeq for other types of sequence validation.
Example yaml_snippet:
-1-2-3from strictyaml import Seq, Str, Int, load from ensure import Ensure Valid Parsed:
Ensure(load(yaml_snippet, Seq(Str()))).equals([&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, ]) Is sequence:
assert load(yaml_snippet, Seq(Str())).is_sequence() Iterator:</description>
    </item>
    
    <item>
      <title>Sequences of unique items (UniqueSeq)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/sequences-of-unique-items/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/sequences-of-unique-items/</guid>
      <description>UniqueSeq validates sequences which contain no duplicate values.
Example yaml_snippet:
-A-B-Cfrom strictyaml import UniqueSeq, Str, load from ensure import Ensure schema = UniqueSeq(Str()) Valid:
Ensure(load(yaml_snippet, schema)).equals([&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;, ]) One dupe:
-A-B-Bload(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: while parsing a sequence in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: - A ^ (line: 1) duplicate found in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 3, column 1: - B ^ (line: 3) All dupes:
-3-3-3load(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: while parsing a sequence in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: - &amp;#39;3&amp;#39; ^ (line: 1) duplicate found in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 3, column 1: - &amp;#39;3&amp;#39; ^ (line: 3) Executable specification</description>
    </item>
    
    <item>
      <title>Shortcut lookup for story names</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/shortcut-lookup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/shortcut-lookup/</guid>
      <description>Hunting for and specifying particular story to run can be a pain.
Using the &amp;lsquo;shortcut&amp;rsquo; function you can select a specific story to run just by specifying one or more key words that appear in the story title. The case is ignored, as are special characters.
If you specify key words that match no stories or more than one story, an error is raised.
example1.story:
Createfile:steps:-CreatefileCreatefileagain:steps:-Createfile example2.story:
Createfiles:steps:-Createfilefrom hitchstory import StoryCollection, BaseEngine from ensure import Ensure from pathquery import pathquery class Engine(BaseEngine): def create_file(self, filename=&amp;#34;step1.</description>
    </item>
    
    <item>
      <title>Should contain text</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/should-contain-text/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/should-contain-text/</guid>
      <description>This example demonstrates .should_contain(&amp;ldquo;text&amp;rdquo;) which first waits for the specified element to appear and then waits for it to contain part or all of the text specified.
HTML:
index.html:
&amp;lt;div class=&amp;#34;form-login&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;id_username&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;username&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;id_password&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;password&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;group-btn&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id_ok_button&amp;#34; href=&amp;#34;/dashboard.html&amp;#34; class=&amp;#34;btn btn-primary btn-md&amp;#34;&amp;gt;login &amp;lt;i class=&amp;#34;fa fa-sign-in&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; selectors.yml:
login:appearswhen:loginpageidentifierelements:loginpageidentifier:id=id_usernameloginbutton:id=id_ok_buttonnonexistent:id=not_there set up:
fromseleniumdirectorimportWebDirectorfromseleniumimportwebdriverdriver=webdriver.Chrome()selector=WebDirector(driver,&amp;#34;selectors.yml&amp;#34;,default_timeout=5) successful:
selector.visit(&amp;#34;http://localhost:8000&amp;#34;) selector.</description>
    </item>
    
    <item>
      <title>Special exception named failure</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/special-failure-exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/special-failure-exception/</guid>
      <description>If you want to indicate a test failure, raise the &amp;ldquo;Failure&amp;rdquo; exception.
This is by default an expected exception, so no stack trace will be printed if it is raised.
example.story:
Failingstory:steps:-Raisespecialfailureexception-Stepthatwillnotrun-Stepthatwillnotrun engine.py:
from hitchstory import BaseEngine, no_stacktrace_for, Failure from code_that_does_things import raise_example_exception, output, ExampleException class Engine(BaseEngine): def passing_step(self): pass def failing_step(self): raise_example_exception(&amp;#34;Towel not located&amp;#34;) @no_stacktrace_for(ExampleException) def failing_step_without_stacktrace(self): raise_example_exception(&amp;#34;Expected exception&amp;#34;) def raise_special_failure_exception(self): raise Failure(&amp;#34;Special failure exception - no stacktrace printed!&amp;#34;) def step_that_will_not_run(self): pass def on_failure(self, result): pass def not_executed_step(self): passfrom hitchstory import StoryCollection from engine import Engine from pathquery import pathquery story_collection = StoryCollection(pathquery(&amp;#34;.</description>
    </item>
    
    <item>
      <title>Story that rewrites itself</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/rewrite-story/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/rewrite-story/</guid>
      <description>Hitch stories can be partially rewritten when the code is changed when a step involves verifying a block of text.
It is a time saver when you only want to make modifications to messages output by a program and ensure that those modifications are verified.
Instead of manually constructing the exact output you are expecting you can simply visually inspect the output to verify that it is the desired output.</description>
    </item>
    
    <item>
      <title>Story with parameters</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/parameterized-stories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/parameterized-stories/</guid>
      <description>Parameterized stories are used to describe stories which are essentially the same except for one or more variables which can vary.
A common example is a story for a user to log in with a browser which may be done with a number of different browsers.
Parameters can be used in preconditions and in steps by surrounding the parameter name with (( brackets )).
example.story:
Clickmagicbutton:with:browser:name:firefoxversion:37given:browser:((browser))steps:-Clickonbutton-Savescreenshot:forbrowser:((browser))variations:withchrome:with:browser:name:chromeversion:153 engine.py:
from hitchstory import BaseEngine, GivenDefinition, GivenProperty, validate from strictyaml import Map, Seq, Int, Str, Optional from code_that_does_things import * class Engine(BaseEngine): given_definition=GivenDefinition( browser=GivenProperty( schema=Map({&amp;#34;name&amp;#34;: Str(), &amp;#34;version&amp;#34;: Int()}), ), ) def set_up(self): print(self.</description>
    </item>
    
    <item>
      <title>StrictYAML</title>
      <link>https://hitchdev.com/strictyaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/</guid>
      <description>StrictYAML is a type-safe YAML parser that parses and validates a restricted subset of the YAML specification.
Priorities:
 Beautiful API Refusing to parse the ugly, hard to read and insecure features of YAML. Strict validation of markup and straightforward type casting. Clear, readable exceptions with code snippets and line numbers. Acting as a near-drop in replacement for pyyaml, ruamel.yaml or poyo. Ability to read in YAML, make changes and write it out again with comments preserved.</description>
    </item>
    
    <item>
      <title>Strong typing</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/strong-typing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/strong-typing/</guid>
      <description>By default all specified given properties and step arguments accept any kind of YAML which will always be parsed to a string or a nested combination of lists, dicts and strings.
In order to restrict what kind of YAML is allowed and/or to parse strings as something else (e.g. integers), you can use the validator decorator on step methods or the schema parameter on the GivenProperty object.
The &amp;lsquo;mini-schemas&amp;rsquo; you feed these objects should be standard StrictYAML validator objects.</description>
    </item>
    
    <item>
      <title>Sub-elements</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/subelements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/subelements/</guid>
      <description>This example demonstrates both how to reference subelements (using subelements:) as well as how to select elements by selector and asking for the parent (using but parent:).
It also shows how to grab these subelements - i.e. parent name / child name.
This is an useful feature when grabbing things in groups or tables.
HTML:
index.html:
&amp;lt;div id=&amp;#34;dashboard&amp;#34;&amp;gt; &amp;lt;h4&amp;gt;Dashboard&amp;lt;/h4&amp;gt; &amp;lt;table id=&amp;#34;founder_table&amp;#34;&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Age&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Company&amp;lt;/th&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td class=&amp;#34;col_name&amp;#34;&amp;gt;Bill Gates&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;#34;col_age&amp;#34;&amp;gt;35&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;#34;col_company&amp;#34;&amp;gt;Microsoft&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td class=&amp;#34;col_name&amp;#34;&amp;gt;Paul Allen&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;#34;col_age&amp;#34;&amp;gt;33&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;#34;col_company&amp;#34;&amp;gt;Microsoft&amp;lt;/td&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;td class=&amp;#34;col_name&amp;#34;&amp;gt;Steve Jobs&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;#34;col_age&amp;#34;&amp;gt;29&amp;lt;/td&amp;gt; &amp;lt;td class=&amp;#34;col_company&amp;#34;&amp;gt;Apple&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/div&amp;gt; selectors.</description>
    </item>
    
    <item>
      <title>The BDD movement&#39;s mistakes - what counts as interesting to &#34;the business&#34;?</title>
      <link>https://hitchdev.com/hitchstory/why/interesting-to-the-business/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/interesting-to-the-business/</guid>
      <description>When Cucumber first gained some popularity, there was something of a backlash from the original developers that the users &amp;ldquo;weren&amp;rsquo;t using it correctly&amp;rdquo;:
The specific complaint was that it was being used as an integration testing framework rather than a tool for &amp;ldquo;communicating with the business&amp;rdquo;.
There are several things wrong with this:
#1 There isn&amp;rsquo;t really a clearly defined &amp;ldquo;the business&amp;rdquo;, there are just stakeholders - lots of different people are interested in the behavior of the software.</description>
    </item>
    
    <item>
      <title>Triality</title>
      <link>https://hitchdev.com/hitchstory/why/triality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/triality/</guid>
      <description>All great software needs three things:
 Specification Tests Documentation  Each of these things is intimately tied. Every new feature must be specified, tested and documented.
If each of these things are done separately, it violates another core principle of software: DRY.
However, if each of these things are intrinsically the same - the specification IS the test which IS the documentation, then there is no need to duplicate effort, code and writing.</description>
    </item>
    
    <item>
      <title>Using StrictYAML</title>
      <link>https://hitchdev.com/strictyaml/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/</guid>
      <description>How to:
 Get line numbers of YAML elements Revalidate an already validated document Build a YAML document from scratch in code Reading in YAML, editing it and writing it back out Labeling exceptions Merge YAML documents Either/or schema validation of two equally valid different kinds of YAML Parsing YAML without a schema  Compound validators:
 Using a YAML object of a parsed mapping Sequence/list validator (Seq) Sequences of unique items (UniqueSeq) Mapping with defined keys and a custom key validator (Map) Fixed length sequences (FixedSeq) Mappings with arbitrary key names (MapPattern) Mappings with defined keys (Map) Validating optional keys in mappings (Map)  Scalar validators:</description>
    </item>
    
    <item>
      <title>Using StrictYAML v0.x.x</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Using a YAML object of a parsed mapping</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-yaml-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/mapping-yaml-object/</guid>
      <description>When a YAML document with mappings is parsed, it is not parsed as a dict but as a YAML object which behaves very similarly to a dict, but with some extra capabilities.
You can use .items(), .keys(), .values(), look up items with square bracket notation, .get(key, with_default_if_nonexistent) and use &amp;ldquo;x in y&amp;rdquo; notation to determine key membership.
To retrieve the equivalent dict (containing just other dicts, lists and strings/ints/etc.) use .</description>
    </item>
    
    <item>
      <title>Using a selenium element object</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/using-selenium-element-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/using-selenium-element-object/</guid>
      <description>If you want to use a selenium object directly (e.g. to implement functionality which seleniumdirector doesn&amp;rsquo;t have), you can use .element.
It&amp;rsquo;s generally a good idea to use the element&amp;rsquo;s iframe context manager. If your element isn&amp;rsquo;t in an iframe it does nothing. If there is an iframe it switches to it.
HTML:
iframe.html:
&amp;lt;p id=&amp;#34;id_dashboard_message&amp;#34;&amp;gt;hello!&amp;lt;/a&amp;gt; index.html:
&amp;lt;div id=&amp;#34;id_login_page&amp;#34; class=&amp;#34;form-login&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;id_username&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;username&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;id_password&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;password&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;group-btn&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id_ok_button&amp;#34; href=&amp;#34;/dashboard.</description>
    </item>
    
    <item>
      <title>Validating optional keys in mappings (Map)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/compound/optional-keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/compound/optional-keys/</guid>
      <description>Not every key in a YAML mapping will be required. If you use the &amp;ldquo;Optional(&amp;lsquo;key&amp;rsquo;)&amp;rdquo; validator with YAML, you can signal that a key/value pair is not required.
from strictyaml import Map, Int, Str, Bool, Optional, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Int(), Optional(&amp;#34;b&amp;#34;): Bool(), }) Valid example 1:
a:1b:yesEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: True}) Valid example 2:
a:1b:noEnsure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: False}) Valid example missing key:
a:1Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: 1}) Invalid 1:</description>
    </item>
    
    <item>
      <title>Validating strings with regexes (Regex)</title>
      <link>https://hitchdev.com/strictyaml/using/alpha/scalar/regular-expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/using/alpha/scalar/regular-expressions/</guid>
      <description>StrictYAML can validate regular expressions and return a string. If the regular expression does not match, an exception is raised.
from strictyaml import Regex, Map, load from ensure import Ensure schema = Map({&amp;#34;a&amp;#34;: Regex(u&amp;#34;[1-4]&amp;#34;), &amp;#34;b&amp;#34;: Regex(u&amp;#34;[5-9]&amp;#34;)}) Parsed correctly:
a:1b:5Ensure(load(yaml_snippet, schema)).equals({&amp;#34;a&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;5&amp;#34;}) Non-matching:
a:5b:5load(yaml_snippet, schema)strictyaml.exceptions.YAMLValidationError: when expecting string matching [1-4] found non-matching string in &amp;#34;&amp;lt;unicode string&amp;gt;&amp;#34;, line 1, column 1: a: &amp;#39;5&amp;#39; ^ (line: 1) Executable specification
Page automatically generated from regexp.</description>
    </item>
    
    <item>
      <title>Variations</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/variations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/variations/</guid>
      <description>Some stories are very similar except for a few changed items. You can create substories within the same story in order to enumerate all of the possible permutations.
This works in the same way as inheritance.
example.story:
Createfiles:given:content:doghierarchicalcontent:x:1y:-42steps:-Dothingwithprecondition-Dootherthing:dog-Doyetanotherthing-Doafourththing:animals:pondanimal:frogvariations:cat:given:content:catfrom hitchstory import StoryCollection, BaseEngine, GivenDefinition, GivenProperty, validate from strictyaml import Map, Seq, Int, Str, Optional from pathquery import pathquery from ensure import Ensure class Engine(BaseEngine): given_definition=GivenDefinition( content=GivenProperty(schema=Str()), hierarchical_content=GivenProperty( schema=Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Seq(Str())}) ), ) def do_other_thing(self, parameter): assert type(parameter) is str print(parameter) def do_thing_with_precondition(self): assert type(self.</description>
    </item>
    
    <item>
      <title>What Cucumber/Gherkin got right</title>
      <link>https://hitchdev.com/hitchstory/why/cucumbers-mistakes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/cucumbers-mistakes/</guid>
      <description>Emphasis on readability of the specs TODO
The idea that specifications should be executable and double as tests TODO
The deliberate use of a simplified configuration language for specifications TODO
Deliberate separation of concerns between specification and story execution TODO
Parameterization TODO
The idea that the notion of specifications, tests and documentation are all intrinsically linked TODO
What Cucumber/Gherkin got wrong Syntax Design English is vague. English is verbose. English is messy.</description>
    </item>
    
    <item>
      <title>What YAML features does StrictYAML remove?</title>
      <link>https://hitchdev.com/strictyaml/features-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/features-removed/</guid>
      <description>StrictYAML restricts you from parsing a number of things which the YAML specification says should be parsed.
This is a demonstration of some of those features:
Implicit Typing x:yesy:null Example pyyaml/ruamel/poyo:
load(yaml) == {&amp;#34;x&amp;#34;: True, &amp;#34;y&amp;#34;: None}  Example StrictYAML
load(yaml) == {&amp;#34;x&amp;#34;: &amp;#34;yes&amp;#34;, &amp;#34;y&amp;#34;: &amp;#34;null&amp;#34;} Direct representations of objects ---!python/hash:UnsafeUserObjectemail:evilhacker@hacker.compassword:passwordtosettype:admin Example pyyaml/ruamel:
load(yaml) == {&amp;#39;evil&amp;#39;: b&amp;#39;z\xf8\xa5u\xabZ&amp;#39;} Example StrictYAML
raises TagTokenDisallowed Duplicate Keys Disallowed x:1x:2 Example pyyaml/poyo:
load(yaml) == {&amp;#39;x&amp;#39;: 2} Example StrictYAML</description>
    </item>
    
    <item>
      <title>What is YAML?</title>
      <link>https://hitchdev.com/strictyaml/what-is-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/what-is-yaml/</guid>
      <description>YAML is a simple, human readable format for representing associative and hierarchical data.
Example from wikipedia page on YAML:
receipt:Oz-WarePurchaseInvoicedate:2012-08-06customer:firstname:Harryfamilyname:Potteraddress:|-4PrivetDrive,LittleWhinging,Englanditems:-part_no:A4786description:WaterBucket(Filled)price:1.47quantity:4-part_no:E1628description:HighHeeled&amp;#34;Ruby&amp;#34;Slipperssize:8price:133.7quantity:1 Key features:
 Things which are associated with other things - delimited by the colon (:). Ordered lists of things - delimited by the prepended dash (-). Multi-line strings - delimited by the bar (|) if there is another newline at the end of the string, or bar + dash (|-) if not.</description>
    </item>
    
    <item>
      <title>What is the difference betweeen a test and a story?</title>
      <link>https://hitchdev.com/hitchstory/why/test-or-story/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/test-or-story/</guid>
      <description>While a test is turing complete code that tests behavior, a story is turing-incomplete code which defines behavior.
A test is simply code that is executed and either raises an exception indicating a failure or passes.
A story must be played using an execution engine.
A story can be translated into readable documentation, often with the aid of artefacts created when running the story (e.g. screenshots).</description>
    </item>
    
    <item>
      <title>What is wrong with duplicate keys?</title>
      <link>https://hitchdev.com/strictyaml/why/duplicate-keys-disallowed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/duplicate-keys-disallowed/</guid>
      <description>Duplicate keys are allowed in regular YAML - as parsed by pyyaml, ruamel.yaml and poyo:
x:cowy:dogx:bull Not only is it unclear whether x should be &amp;ldquo;cow&amp;rdquo; or &amp;ldquo;bull&amp;rdquo; (the parser will decide &amp;lsquo;bull&amp;rsquo;, but did you know that?), if there are 200 lines between x: cow and x: bull, a user might very likely change the first x and erroneously believe that the resulting value of x has been changed - when it hasn&amp;rsquo;t.</description>
    </item>
    
    <item>
      <title>What is wrong with explicit syntax typing in a readable configuration language?</title>
      <link>https://hitchdev.com/strictyaml/why/syntax-typing-bad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/syntax-typing-bad/</guid>
      <description>Explicit syntax typing is the process of using syntax to define types in markup. So, for instance in JSON, quotation marks are used to define name as a string and age as a number:
´´´json {&amp;ldquo;name&amp;rdquo;: &amp;ldquo;Arthur Dent&amp;rdquo;, &amp;ldquo;age&amp;rdquo;: 42} ´´´
This helps distinguish the types for the parser, which is useful for JSON, but it also comes with two disadvantages:
 The distinction is subtle and not particularly clear to non-programmers, who will not necessarily understand that a directive needs to be given to the parser to avoid it being misinterpreted.</description>
    </item>
    
    <item>
      <title>What is wrong with explicit tags?</title>
      <link>https://hitchdev.com/strictyaml/why/explicit-tags-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/explicit-tags-removed/</guid>
      <description>Explicit tags are tags that have an explicit type attached that is used to determine what type to convert the data to when it is parsed.
For example, if it were to be applied to &amp;ldquo;fix&amp;rdquo; the Godfather movie script parsing issue described above, it would look like this:
-DonCorleone:Doyouhavefaithinmyjudgment?-Clemenza:!!strYes-DonCorleone:DoIhaveyourloyalty? Explicit typecasts in YAML markup are slightly confusing for non-programmers, much like the concept of &amp;lsquo;types&amp;rsquo; in general. StrictYAML&amp;rsquo;s philosophy is that types should be kept strictly separated from data, so this &amp;lsquo;feature&amp;rsquo; of YAML is switched off.</description>
    </item>
    
    <item>
      <title>What is wrong with flow style YAML?</title>
      <link>https://hitchdev.com/strictyaml/why/flow-style-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/flow-style-removed/</guid>
      <description>Flow style is essentially JSON embedded in YAML - making use of curly { } and square brackets to denote lists and mappings.
Example:
a:1b:{c:3,d:4} This use of JSONesque { and } is also ugly and hampers readability - especially when { and } are used for other purposes (e.g. templating) and the human reader/writer of YAML has to give themselves a headache figuring out what kind of curly bracket it is.</description>
    </item>
    
    <item>
      <title>What is wrong with implicit typing?</title>
      <link>https://hitchdev.com/strictyaml/why/implicit-typing-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/implicit-typing-removed/</guid>
      <description>Imagine you are parsing a DSL to represent movie scripts:
-DonCorleone:Doyouhavefaithinmyjudgment?-Clemenza:Yes-DonCorleone:DoIhaveyourloyalty? Parse output of pyyaml, ruamel.yaml and Poyo:
&amp;gt;&amp;gt;&amp;gt; from ruamel.yaml import load &amp;gt;&amp;gt;&amp;gt; load(the_godfather) [{&amp;#39;Don Corleone&amp;#39;: &amp;#39;Do you have faith in my judgement?&amp;#39;}, {&amp;#39;Clemenza&amp;#39;: True}, {&amp;#39;Don Corleone&amp;#39;: &amp;#39;Do I have your loyalty?&amp;#39;},] Wait, Clemenza said what??
Parse output of StrictYAML without validators:
&amp;gt;&amp;gt;&amp;gt; from strictyaml import load, List, MapPattern, Str &amp;gt;&amp;gt;&amp;gt; load(the_godfather) [{&amp;#39;Don Corleone&amp;#39;: &amp;#39;Do you have faith in my judgement?</description>
    </item>
    
    <item>
      <title>What is wrong with node anchors and references?</title>
      <link>https://hitchdev.com/strictyaml/why/node-anchors-and-references-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/node-anchors-and-references-removed/</guid>
      <description>An example of a snippet of YAML that uses node anchors and references is described on the YAML wikipedia page:
# sequencer protocols for Laser eye surgery----step:&amp;amp;id001# defines anchor label &amp;amp;id001instrument:Lasik2000pulseEnergy:5.4pulseDuration:12repetition:1000spotSize:1mm-step:&amp;amp;id002instrument:Lasik2000pulseEnergy:5.0pulseDuration:10repetition:500spotSize:2mm-step:*id001# refers to the first step (with anchor &amp;amp;id001)-step:*id002# refers to the second step-step:&amp;lt;&amp;lt;:*id001spotSize:2mm# redefines just this key, refers rest from &amp;amp;id001-step:*id002 While the intent of the feature is obvious (it lets you deduplicate code), the effect is to make the markup more or less unreadable to non-programmers.</description>
    </item>
    
    <item>
      <title>When should I use a validator and when should I not?</title>
      <link>https://hitchdev.com/strictyaml/when-to-use-validators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/when-to-use-validators/</guid>
      <description>When starting out on greenfield projects it&amp;rsquo;s much quicker not to create a validator. In such cases it&amp;rsquo;s often more prudent to just parse the YAML and convert the strings explicitly on the fly (e.g. int(yaml[&amp;lsquo;key&amp;rsquo;])).
If the YAML is also going to be largely under the control of the developer it also might not make sense to write a validator either.
If you have written software that is going to parse YAML from a source you do not control - especially by somebody who might make a mistake - then it probably does make sense to write a validator.</description>
    </item>
    
    <item>
      <title>Why did you not use standard YAML for hitch?</title>
      <link>https://hitchdev.com/hitchstory/why/standard-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/standard-yaml/</guid>
      <description>hitchtest (the precursor to hitchstory) actually did use standard YAML and the more I used it the more convinced I was that it contained serious flaws.
I wrote StrictYAML, which is a restricted subset of standard YAML, in response to those flaws. It replaces implicit typing with strong typing and deactivates rarely used and confusing YAML features.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML make you define a schema in python - a turing complete language?</title>
      <link>https://hitchdev.com/strictyaml/why/turing-complete-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/turing-complete-schema/</guid>
      <description>StrictYAML defines schemas in python (i.e. turing complete) code. For example:
Map({&amp;#34;name&amp;#34;: Str(), &amp;#34;email&amp;#34;: Str()}) Instead of:
type:mapmapping:&amp;#34;name&amp;#34;:type:strrequired:yes&amp;#34;email&amp;#34;:type:strrequired:yes There are some trade offs here:
Schema definition in a non-turing complete language like YAML makes the schema programming language independent and gives it more potential for being read and understood by non-programmers.
However, schema definition in a non-turing complete language also restricts and makes certain use cases impossible or awkward.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML not parse direct representations of python objects?</title>
      <link>https://hitchdev.com/strictyaml/why/binary-data-removed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/binary-data-removed/</guid>
      <description>StrictYAML doesn&amp;rsquo;t allow direct representations of python objects. For example:
---!python/hash:UnsafeUserObjectemail:evilhacker@hacker.compassword:passwordtosettype:admin This anti-feature led to Ruby on Rails&amp;rsquo; spectacular security fail.</description>
    </item>
    
    <item>
      <title>Why does StrictYAML only parse from strings and not files?</title>
      <link>https://hitchdev.com/strictyaml/why/only-parse-strings-not-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/only-parse-strings-not-files/</guid>
      <description>While other parsers will take strings, file handles and file names, StrictYAML will only parse YAML strings.
This is done deliberately to reduce the module&amp;rsquo;s remit, with the intention of reducing both the potential bug surface and the number of exceptions that StrictYAML has to deal with - things like nonexistent files, file system errors, bad reads, unknown file extensions, etc. become the problem of some other module - ideally one more focused on handling those kinds of issues.</description>
    </item>
    
    <item>
      <title>Why is parsing speed not a high priority for StrictYAML?</title>
      <link>https://hitchdev.com/strictyaml/why/speed-not-a-priority/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why/speed-not-a-priority/</guid>
      <description>JSON and StrictYAML are essentially complementary formats. They both allow a relatively loose representation of data that just contains, mappings and sequences. They are serialization formats that are relatively straightforward for both humans and machines to read and write.
The main difference is simply one of degree:
JSON is primariliy optimized for machine readability and writability, while still maintaining human readability.
YAML is optimized for human readability and writability, while maintaining machine readability and writability.</description>
    </item>
    
    <item>
      <title>Why not HOCON?</title>
      <link>https://hitchdev.com/strictyaml/why-not/hocon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/hocon/</guid>
      <description>HOCON is another &amp;ldquo;redesigned&amp;rdquo; JSON, ironically enough, taking JSON and making it even more complicated.
Along with JSON&amp;rsquo;s syntax typing - a downside of most non-YAML alternatives, HOCON makes the following mistakes in its design:
 It does not fail loudly on duplicate keys. It has a confusing rules for deciding on concatenations and substitutions. -* It has a mechanism for substitutions similar to YAML&amp;rsquo;s node/anchor feature - which, unless used extremely sparingly, can create confusing markup that, ironically, is not human optimized.</description>
    </item>
    
    <item>
      <title>Why not JSON for simple configuration files?</title>
      <link>https://hitchdev.com/strictyaml/why-not/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/json/</guid>
      <description>JSON is an ideal format for REST APIs and other forms of data intended for machine exchange and it probably always will be because:
 It&amp;rsquo;s a simple spec. It has all the basic types which map on to all programming languages - number, string, list, mapping, boolean and no more. Its syntax contains a built in level of error detection - cut a JSON request in half and it is no longer still valid, eliminating an entire class of obscure and problematic bugs.</description>
    </item>
    
    <item>
      <title>Why not JSON5?</title>
      <link>https://hitchdev.com/strictyaml/why-not/json5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/json5/</guid>
      <description>JSON5 is also a proposed extension to JSON to make it more readable.
Its main criticism of YAML is::
There are other formats that are human-friendlier, like YAML, but changing from JSON to a completely different format is undesirable in many cases.
This is, I belive, mistaken. It is better if a language is not subtly different if you are going to use it as such. Subtle differences invite mistakes brought on by confusion.</description>
    </item>
    
    <item>
      <title>Why not X?</title>
      <link>https://hitchdev.com/seleniumdirector/why-not/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/why-not/</guid>
      <description>Why not use Capybara-Py or Splinter? Why not use Robot SeleniumLibrary? Why not use the page object pattern?  If you&amp;rsquo;d like to write or link to a rebuttal to any argument raised here, feel free to raise a ticket.</description>
    </item>
    
    <item>
      <title>Why not X?</title>
      <link>https://hitchdev.com/strictyaml/why-not/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/</guid>
      <description>There are a number of formats and approaches that can achieve more or less the same purpose as StrictYAML. Below is a series of comparisons with some of the more famous ones:
 Why not JSON for simple configuration files? Why not use TOML? Why not use the YAML 2.0 standard? - we don&amp;rsquo;t need a new standard! Why not use kwalify with standard YAML to validate my YAML? Why not use python&amp;rsquo;s schema library for validation?</description>
    </item>
    
    <item>
      <title>Why not use Capybara-Py or Splinter?</title>
      <link>https://hitchdev.com/seleniumdirector/why-not/capybara-py-or-splinter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/why-not/capybara-py-or-splinter/</guid>
      <description>Capybara-Py (and Capybara) and Splinter are both wrappers around selenium which can be used to write acceptance tests.
Similar to seleniumdirector, both wrap around a selenium Webdriver object and provide a nicer API on it. They by and large provide all the same functionality that selenium does.
Seleniumdirector is different because separates selector management from actions on elements. Selectors are specified in a YAML file while actions are executed with code.</description>
    </item>
    
    <item>
      <title>Why not use Cucumber or other Gherkin-derived languages?</title>
      <link>https://hitchdev.com/hitchstory/why/cucumber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/cucumber/</guid>
      <description>Python equivalents: lettuce, behave Java equivalent: JBehave
Cucumber was the original &amp;lsquo;BDD&amp;rsquo; frameworks and probably the most popular. It is essentially a parser for the Gherkin language, which is a high level &amp;ldquo;English-like&amp;rdquo; declarative language that can be used to specify user stories which can be executed.
This approach has the following advantages:
 Stories are descriptive and declarative. Turing complete languages (python, Java, Ruby, C, etc.) are more powerful than necessary to describe user stories.</description>
    </item>
    
    <item>
      <title>Why not use INI files?</title>
      <link>https://hitchdev.com/strictyaml/why-not/ini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/ini/</guid>
      <description>INI is a very old and quite readable configuration format. Unfortunately it suffers from two major problems:
 Different parsers will operate in subtly different ways that can lead to often obscure bugs regarding the way whitespace is used, case sensitivity, comments and escape characters. It doesn&amp;rsquo;t let you represent hierarchical data.  In a way, TOML</description>
    </item>
    
    <item>
      <title>Why not use JSON Schema for validation?</title>
      <link>https://hitchdev.com/strictyaml/why-not/json-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/json-schema/</guid>
      <description>JSON schema can also be used to validate YAML. This presumes that you might want to use jsonschema and pyyaml/ruamel.yaml together.
[ TODO Flesh out ]
 Line numbers Simpler errors in StrictYAML StrictYAML is a more flexible schema Turing incompleteness / inflexibility  </description>
    </item>
    
    <item>
      <title>Why not use Robot SeleniumLibrary?</title>
      <link>https://hitchdev.com/seleniumdirector/why-not/robot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/why-not/robot/</guid>
      <description>Robot&amp;rsquo;s SeleniumLibrary is a layer around selenium designed to integrate it with the Robot framework. It is designed to create test cases like this:
*** Settings *** Library SeleniumLibrary *** Test Cases *** The user can search for flights [Tags]	search_flights Open browser http://blazedemo.com/ Chrome Select From List By Value xpath://select[@name=&#39;fromPort&#39;] Paris Select From List by Value xpath://select[@name=&#39;toPort&#39;] London Click Button css:input[type=&#39;submit&#39;] @{flights}= Get WebElements css:table[class=&#39;table&#39;]&amp;gt;tbody tr Should Not Be Empty ${flights} Close All Browsers  Example taken from https://www.</description>
    </item>
    
    <item>
      <title>Why not use SDLang?</title>
      <link>https://hitchdev.com/strictyaml/why-not/sdlang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/sdlang/</guid>
      <description>SDLang or &amp;ldquo;simple declarative language&amp;rdquo; is a proposed configuration language with an XML-like structure inspired by C.
Example:
// This is a node with a single string value title &amp;quot;Hello, World&amp;quot; // Multiple values are supported, too bookmarks 12 15 188 1234 // Nodes can have attributes author &amp;quot;Peter Parker&amp;quot; email=&amp;quot;peter@example.org&amp;quot; active=true // Nodes can be arbitrarily nested contents { section &amp;quot;First section&amp;quot; { paragraph &amp;quot;This is the first paragraph&amp;quot; paragraph &amp;quot;This is the second paragraph&amp;quot; } } // Anonymous nodes are supported &amp;quot;This text is the value of an anonymous node!</description>
    </item>
    
    <item>
      <title>Why not use TOML?</title>
      <link>https://hitchdev.com/strictyaml/why-not/toml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/toml/</guid>
      <description>TOML is a redesigned configuration language that&amp;rsquo;s essentially an extended version of INI which allows the expression of both hierarchical and typed data.
TOML&amp;rsquo;s main criticism of YAML is spot on::
TOML aims for simplicity, a goal which is not apparent in the YAML specification.
StrictYAML&amp;rsquo;s cut down version of the YAML specification - with implicit typing, node anchors/references and flow style cut out, ends up being simpler than TOML.</description>
    </item>
    
    <item>
      <title>Why not use XML for configuration or DSLs?</title>
      <link>https://hitchdev.com/strictyaml/why-not/xml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/xml/</guid>
      <description>XML suffers from overcomplication much like vanilla YAML does - although to an ever greater degree, thanks to the committee driven design. Doctypes and namespaces are horrendous additions to the language, for instance. XML is not only not really human readable (beyond a very basic subset of the language), it&amp;rsquo;s often barely programmer readable despite being less expressive than most turing complete languages. It&amp;rsquo;s a flagrant violation of the rule of least power.</description>
    </item>
    
    <item>
      <title>Why not use kwalify with standard YAML to validate my YAML?</title>
      <link>https://hitchdev.com/strictyaml/why-not/pykwalify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/pykwalify/</guid>
      <description>Kwalify is a schema validation language that is written in YAML.
It is a descriptive schema language suitable for validating simple YAML.
Kwalify compiles to the strictyaml equivalent but is able to do less. You cannot, for example:
 Plug generated lists that come from outside of the spec (e.g. a list of country code from pycountry). Validate parts of the schema which can be either one thing or another - e.</description>
    </item>
    
    <item>
      <title>Why not use python&#39;s schema library for validation?</title>
      <link>https://hitchdev.com/strictyaml/why-not/python-schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/python-schema/</guid>
      <description>Python&amp;rsquo;s &amp;lsquo;schema&amp;rsquo; (as well as similar libraries) can also be used to validate the structure of objects. Validating YAML is even cited as a reason on their README.
Problems:
 Line numbers and code snippets not reported on errors. YAML&amp;rsquo;s implicit typing will still ruin validation. Roundtripping is much less straightforward.  [ TODO flesh out ]</description>
    </item>
    
    <item>
      <title>Why not use the Robot Framework?</title>
      <link>https://hitchdev.com/hitchstory/why-not/robot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why-not/robot/</guid>
      <description>HitchDev was, in a sense, inspired by the robot framework. I used it many years ago and became incredibly frustrated using it for debugging.
The last straw was trying to debug a robot test failure and discovering that the step that the test failed on was not displayed to the end user. It turned out that the maintainers had reasons for doing this, but they were bad reasons.
I eventually dumped it and used python&amp;rsquo;s built in unit testing framework, which is unsuitable for many other reasons.</description>
    </item>
    
    <item>
      <title>Why not use the YAML 2.0 standard? - we don&#39;t need a new standard!</title>
      <link>https://hitchdev.com/strictyaml/why-not/ordinary-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/ordinary-yaml/</guid>
      <description>StrictYAML is composed of two parts:
 A new YAML specification which parses a restricted subset of the YAML 2.0 specification and only parse to ordered dict, list or string. An optional validator (which will, as requested, validate and cast parse some of those scalar string values to ints, floats, datetimes, etc.).  Note that StrictYAML is not a new standard. If you have a syntax highlighter or editor or anything else that recognizes or reads YAML it will recognize StrictYAML in the same way.</description>
    </item>
    
    <item>
      <title>Why not use the page object pattern?</title>
      <link>https://hitchdev.com/seleniumdirector/why-not/page-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/why-not/page-object/</guid>
      <description>The page object pattern is a design pattern for creating a code API abstraction around web pages to simplify their usage in GUI tests.
The idea of the page object pattern is is to enact a separation of concerns between the code that interacts directly with HTML and the code which interacts with the web application.
While identifying a real problem and proposing a solution that works to solve that problem, it is not the most elegant solution to that problem.</description>
    </item>
    
    <item>
      <title>Why shouldn&#39;t I just use python code for configuration?</title>
      <link>https://hitchdev.com/strictyaml/why-not/turing-complete-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/strictyaml/why-not/turing-complete-code/</guid>
      <description>This isn&amp;rsquo;t uncommon and can often seem like a nice, simple solution although using a turing complete language for configuration will often have nasty side effects.
Why does using YAML (or indeed, any configuration language) avoid this? Because they are less powerful languages than python.
While this may not intrinsically seem like a good thing (more power seems better at first glance), it isn&amp;rsquo;t:
 We need less powerful languages. Rule of least power (wikipedia).</description>
    </item>
    
    <item>
      <title>Why unit testing needs to die</title>
      <link>https://hitchdev.com/hitchstory/why/why-not-unit-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/why-not-unit-test/</guid>
      <description>This is a controversial argument but, one that needs to be made:
The world needs to move on from unit testing.
It ought to be noted that this is not an argument against any of the following, which are often conflated with unit testing:
 Testing in general Property based testing (e.g. hypothesis). Test driven development The testing pyramid Mocking  All of those things are great. Please do not mistake this as an argument against any of them in principle.</description>
    </item>
    
    <item>
      <title>With HTML attributes</title>
      <link>https://hitchdev.com/seleniumdirector/using/alpha/attributes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/using/alpha/attributes/</guid>
      <description>This example demonstrates how to use HTML attributes to select and use HTML elements by using &amp;lsquo;attribute: attrib-name=attrib-value&amp;rsquo;.
If there is more than one element matching that attribute, the element to use can be specified using &amp;lsquo;which: [ number ]&amp;rsquo; or which: last.
HTML:
index.html:
&amp;lt;div data-id=&amp;#34;login-page&amp;#34; class=&amp;#34;form-login&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; data-id=&amp;#34;username&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;username&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; data-id=&amp;#34;password&amp;#34; class=&amp;#34;form-control input-sm chat-input&amp;#34; placeholder=&amp;#34;password&amp;#34; /&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;group-btn&amp;#34;&amp;gt; &amp;lt;a data-id=&amp;#34;ok&amp;#34; href=&amp;#34;/dashboard.</description>
    </item>
    
    <item>
      <title>Write code with the least expressive power</title>
      <link>https://hitchdev.com/principles/code-quality/least-expressive-power/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/principles/code-quality/least-expressive-power/</guid>
      <description>Write code with the least expressive power necessary is a [tradeoff principle of code quality].
Examples  YAML vs Python The story of JSON Whither garbage collector Metaprogramming LINQ vs. C# SQL vs. imperative The DSL merry-go-round C++ templating language  Subprinciples These are principles which can be partially or in whole be derived from this principle.
 Immutability vs. Mutability (side effects) State isolation Lazy evaluation Principle of least privilege in protocol design  Other people talking about the same principle These explanations discuss languages as if their power is uniform and static, whereas this principle also applies to problems and the power of features used to solve them within the same language.</description>
    </item>
    
    <item>
      <title>Write the least code possible</title>
      <link>https://hitchdev.com/principles/code-quality/write-least-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/principles/code-quality/write-least-code/</guid>
      <description> If you don&amp;rsquo;t need it, don&amp;rsquo;t write it.
If you wrote it twice or thrice, deduplicate it.
Subprinciples  DRY Don&amp;rsquo;t reinvent the wheel YAGNI  </description>
    </item>
    
  </channel>
</rss>
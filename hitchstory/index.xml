<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hitchstories on HitchDev</title>
    <link>https://hitchdev.com/hitchstory/</link>
    <description>Recent content in Hitchstories on HitchDev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (C) 2018</copyright>
    
	<atom:link href="https://hitchdev.com/hitchstory/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Abort a story with ctrl-C</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/aborting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/aborting/</guid>
      <description>When an in-progress story is hit with any of the following termination signals:
 SIGTERM SIGINT SIGQUIT SIGHUP  Then it triggers the tear_down method of the engine.
In practical terms this means that if you are running a series of stories, Ctrl-C should halt current execution, run tear_down and then not run any more stories.
example.story:
Createfiles:steps:-PauseforeverShouldneverrun:steps:-Shouldnothappen engine.py:
from hitchstory import BaseEngine from code_that_does_things import reticulate_splines import psutil class Engine(BaseEngine): def pause_forever(self): psutil.</description>
    </item>
    
    <item>
      <title>Arguments to steps</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/steps-and-step-arguments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/steps-and-step-arguments/</guid>
      <description>Arguments are fed to steps in a way that is largely consistent with how python methods work:
 Named arguments (e.g. &amp;ldquo;How many times&amp;rdquo;) are put in equivalent named variables (e.g. &amp;ldquo;how_many_times&amp;rdquo;). If the method has **kwargs then the key names of kwargs will match the named arguments exactly (i.e. no underscores).  engine.py:
from code_that_does_things import * from strictyaml import Int, Str, Bool from hitchstory import BaseEngine, validate class Engine(BaseEngine): def fill_form(self, **kwargs): for name, content in kwargs.</description>
    </item>
    
    <item>
      <title>Can I do BDD with hitchstory? How do I do BDD with hitchstory?</title>
      <link>https://hitchdev.com/hitchstory/approach/bdd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/bdd/</guid>
      <description>Short answer: yes, but you can also do BDD with a pencil and a napkin.
The time when it was most useful as a &amp;ldquo;BDD tool&amp;rdquo; was when I was working with an extremely technical product manager who was proposing behavior in a command line tool he wanted.
Initially I received a word document describing the complex logic flows and behavior which he wanted. Gradually I turned those descriptions in to HitchStory specifications that described how the command line tool was supposed to behave.</description>
    </item>
    
    <item>
      <title>Continue on failure when playing multiple stories</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/continue-on-failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/continue-on-failure/</guid>
      <description>By default whenever stories are played in sequence, they stop when the first failure is encountered.
However, if your stories take a long time to run you may wish to continue after the first failure.
example1.story:
ACreatefile:steps:-CreatefileBCreatefile:steps:-Fail example2.story:
CCreatefileathirdtime:steps:-Createfilefrom hitchstory import StoryCollection, BaseEngine from pathquery import pathquery class Engine(BaseEngine): def create_file(self, filename=&amp;#34;step1.txt&amp;#34;, content=&amp;#34;example&amp;#34;): with open(filename, &amp;#39;w&amp;#39;) as handle: handle.write(content) def fail(self): raise Exception(&amp;#34;Error&amp;#34;) Stop on failure is default behavior:
StoryCollection( pathquery(&amp;#34;.</description>
    </item>
    
    <item>
      <title>Declarative User Stories</title>
      <link>https://hitchdev.com/hitchstory/why/declarative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/declarative/</guid>
      <description>HitchStory StoryFiles are declarative and not turing complete.
At their core, they essentially just contain marked up data - a set of preconditions (in &amp;lsquo;given&amp;rsquo;), a set of steps and arguments and the ability to parameterize the preconditions, step arguments and inherit one story from another.
No loops. No if statements. Deliberately turing incomplete.
Using a less powerful language to write tests in sounds counter-intuitive. Surely you want as much power as possible when writing tests so you can do as much as possible?</description>
    </item>
    
    <item>
      <title>Design Justifications</title>
      <link>https://hitchdev.com/hitchstory/why/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/</guid>
      <description>HitchStory is the result of some carefully considered, although controversial design decisions. These are justified here.
 I see given but where is when and then? Why does HitchStory use StrictYAML? Why does hitchstory not have an opinion on what counts as interesting to &amp;ldquo;the business&amp;rdquo;? Discussion of requested feature inheritance in Cucumber Declarative User Stories Two Unit Tests, Zero Integration Tests  Rebuttals and critiques, especially from users and designers of competing tools are welcome.</description>
    </item>
    
    <item>
      <title>Discussion of requested feature inheritance in Cucumber</title>
      <link>https://hitchdev.com/hitchstory/why/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/inheritance/</guid>
      <description>Inheritance is a feature which was deliberately left out of Cucumber:
https://stackoverflow.com/questions/41872376/can-a-cucumber-feature-file-inherit-from-a-parent-feature-file
However, it was deliberately added to hitchstory.</description>
    </item>
    
    <item>
      <title>Does hitchstory let your BA or Product Manager write stories while you just write the code?</title>
      <link>https://hitchdev.com/hitchstory/approach/human-writable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/human-writable/</guid>
      <description>No. Having &amp;ldquo;analysts&amp;rdquo; write stories instead of programmers is an explicit non-goal, unlike that of Cucumber. Well maintained stories require the eye of a programmer - to ensure they are DRY and to maintain a proper separation of concerns between implementation and specification.
It ought to be possible to write hitch stories with less training than is required to be a programmer since the language is conceptually simpler than turing complete programming languages.</description>
    </item>
    
    <item>
      <title>Extra story metadata - e.g. adding JIRA ticket numbers to stories</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/metadata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/metadata/</guid>
      <description>Each and every story is related to issues on issue trackers, specialist documentation, people, external resources and much more.
The best place to document this additional metadata is not buried in word documents on company wikis but within the story itself.
What kind of metadata you add to stories is up to you - simply add the names of the properties you want to add in the info parameter of your engine InfoDefinition and specify the structure of the metadata using StrictYAML validators inside the InfoProperty object.</description>
    </item>
    
    <item>
      <title>Flaky Tests</title>
      <link>https://hitchdev.com/hitchstory/approach/flaky-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/flaky-tests/</guid>
      <description>Flaky tests are tests which will do not pass or fail consistently.
Higher level tests suffer more from flakiness than low level tests, although this tends to be only because high level tests are testing more code.
The probability of flakiness increases with the amount of code being tested.
How to deal with flakiness? Extreme flakiness can lead to test failure habituation and, in extreme cases, test abandonment.
Flakiness in any test should mainly be considered an undesirable property to test for and, when detected, a bug to be fixed.</description>
    </item>
    
    <item>
      <title>Flaky story detection</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/flaky-story-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/flaky-story-detection/</guid>
      <description>Dealing with flaky stories, especially with higher level integration tests is a constant battle.
These examples show how flaky stories can be detected by rerunning stories several times and checking that the result is the same. This kind of regression testing can be usefully run separately from normal regression testing in order to get separate feedback about problematic tests in a &amp;lsquo;flake&amp;rsquo; report.
This cannot detect all kinds of flakiness, but it can be effective at detecting flakiness caused by, for example:</description>
    </item>
    
    <item>
      <title>General Approach</title>
      <link>https://hitchdev.com/hitchstory/approach/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/</guid>
      <description>HitchStory best practices are documented here:
{% for dirfile in thisdir.is_not_dir() - thisdir.named(&amp;ldquo;index.md&amp;rdquo;) -%} - {{ title(dirfile) }} {% endfor %}</description>
    </item>
    
    <item>
      <title>Generate documentation from stories</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/generate-documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/generate-documentation/</guid>
      <description>While hitchstory YAML stories are designed to be as readable as possible while still remaining terse and easy to maintain, it is not readable user documentation and is not intended for use by stakeholders to understand how a system operates.
However, stakeholders do need documentation and user stories form an excellent base to build documentation from.
Using hitchstory story and story list objects you can generate documentation using a simple templating language.</description>
    </item>
    
    <item>
      <title>Given preconditions</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/given/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/given/</guid>
      <description>Stories are comprised of preconditions followed by steps.
Hitchstory lets you define preconditions using the &amp;lsquo;given&amp;rsquo; keyword in YAML and then use them using self.given[&amp;lsquo;property name&amp;rsquo;].
The given property names need to first be specified in the engine using GivenDefinition and GivenProperty.
By default, given properties will parse without a StrictYAML schema, but you can also specify your own StrictYAML schema.
The following example shows a browser precondition being used to set up a mock selenium object.</description>
    </item>
    
    <item>
      <title>Gradual typing of story steps</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/gradual-typing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/gradual-typing/</guid>
      <description>In order to speed up prototyping and development of a story suite, the structure of your YAML data specified in preconditions, parameters and step arguments need not be specified in advance.
All data that is parsed without a validator is parsed either as a dict, list or string, as per the StrictYAML spec.
When your story suite matures and the structure of your story files has solidified, you can specify validators that fail fast when YAML snippets with an invalid structure are used.</description>
    </item>
    
    <item>
      <title>Handling failing tests</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/failing-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/failing-tests/</guid>
      <description>By default, a failing story will show:
 A snippet of the YAML where the story failed with the failing step highlighted. A stack trace from engine.py where the exception was raised.  example.story:
Failingstory:steps:-Passingstep-Failingstep-Notexecutedstep engine.py:
from hitchstory import BaseEngine, no_stacktrace_for, Failure from code_that_does_things import raise_example_exception, output, ExampleException class Engine(BaseEngine): def passing_step(self): pass def failing_step(self): raise_example_exception(&amp;#34;Towel not located&amp;#34;) @no_stacktrace_for(ExampleException) def failing_step_without_stacktrace(self): raise_example_exception(&amp;#34;Expected exception&amp;#34;) def raise_special_failure_exception(self): raise Failure(&amp;#34;Special failure exception - no stacktrace printed!</description>
    </item>
    
    <item>
      <title>Hiding stacktraces for expected exceptions</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/expected-exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/expected-exceptions/</guid>
      <description>For common expected failures where you do not want to see the whole stacktrace, apply the &amp;ldquo;@no_stacktrace_for&amp;rdquo; decorator.
example.story:
Failingstory:steps:-Failingstepwithoutstacktrace engine.py:
from hitchstory import BaseEngine, no_stacktrace_for, Failure from code_that_does_things import raise_example_exception, output, ExampleException class Engine(BaseEngine): def passing_step(self): pass def failing_step(self): raise_example_exception(&amp;#34;Towel not located&amp;#34;) @no_stacktrace_for(ExampleException) def failing_step_without_stacktrace(self): raise_example_exception(&amp;#34;Expected exception&amp;#34;) def raise_special_failure_exception(self): raise Failure(&amp;#34;Special failure exception - no stacktrace printed!&amp;#34;) def step_that_will_not_run(self): pass def on_failure(self, result): pass def not_executed_step(self): passfrom hitchstory import StoryCollection from engine import Engine from pathquery import pathquery story_collection = StoryCollection(pathquery(&amp;#34;.</description>
    </item>
    
    <item>
      <title>HitchStory</title>
      <link>https://hitchdev.com/hitchstory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/</guid>
      <description>HitchStory is a python 3 library for creating readable &amp;ldquo;specifications by example&amp;rdquo; and executing them. It is an ambitious project intended supplant both traditional BDD tools and unit tests.
Unlike many other BDD tools the specification is written using StrictYAML which means that stories will be terse, strongly typed and expressive enough to describe business rules and behavior in precise detail.
Example example.story:
Login:given:website:/login# preconditionssteps:-Fillform:username:AzureDiamond# parameterized stepspassword:hunter2-Click:loginSendemail:about:Corefunctionalityofapp.basedon:login# inherits from and continues from test abovesteps:-Click:newemail-Fillform:to:Cthon98@aol.</description>
    </item>
    
    <item>
      <title>I see given but where is when and then?</title>
      <link>https://hitchdev.com/hitchstory/why/given-when-then/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/given-when-then/</guid>
      <description>You can certainly write user stories using when and then like so:
Given:Ihave:redboxSteps:-WhenIclick:theredbutton-Thenitgoeskaboom However, hitchstory does not require this, and it is not generally encouraged because, as with code, terseness and ease of editing is of primary importance and this languge is designed for use primarily by programmers.
Writing the story like this is terser and no less clear:
given:box:redsteps:-click:redbutton-goeskaboom Where stakeholders wish to read documentation that is longer form and more flowing, the latter can still be used to generate it.</description>
    </item>
    
    <item>
      <title>Inherit one story from another</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/inheritance/</guid>
      <description>You can break most software down into a series of individual linear behavioral stories.
However, software stories naturally branch. In order to send an email or delete an email you must first always log in.
While it would be possible to write out each individual story for every possible branch, this would result in a story suite that is WET instead of DRY and that creates a maintenance headache.
Story inheritance allows you to base stories on other stories.</description>
    </item>
    
    <item>
      <title>Play multiple stories in sequence</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/play-multiple-stories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/play-multiple-stories/</guid>
      <description>Running multiple stories in sequence is necessary when you want to do a regression sweep to make sure nothing has broken.
By default hitchstory will stop when it sees its first failure. This behavior can be changed though.
Example base.story:
Basestory:given:randomvariable:somevalue example1.story:
Createfile:basedon:basestorysteps:-CreatefileCreatefileagain:basedon:basestorysteps:-Createfile example2.story:
Createfiles:basedon:basestorysteps:-Createfilefrom hitchstory import StoryCollection, BaseEngine, GivenDefinition, GivenProperty from pathquery import pathquery from ensure import Ensure class Engine(BaseEngine): given_definition=GivenDefinition( random_variable=GivenProperty() ) def create_file(self, filename=&amp;#34;step1.txt&amp;#34;, content=&amp;#34;example&amp;#34;): with open(filename, &amp;#39;w&amp;#39;) as handle: handle.</description>
    </item>
    
    <item>
      <title>Recommended Environment</title>
      <link>https://hitchdev.com/hitchstory/approach/recommended-environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/recommended-environment/</guid>
      <description>HitchStory was designed and built on the presumption that it would always be run in a different environment to the environment used to run the code. This is in stark contrast to how unit testing frameworks are presumed to run - i.e. in python, in the same virtualenv.
There are two reasons for this:
 HitchStory dependencies and related tools are unable to conflict with application code if they run in a separate, segrated environment.</description>
    </item>
    
    <item>
      <title>Running a single named story successfully</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/run-single-named-story/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/run-single-named-story/</guid>
      <description>How a story runs when it is successful - i.e. when no exception is raised during its run.
example.story:
Createfiles:steps:-Createfile-Createfile:step2.txt-Createfile:filename:step3.txtcontent:thirdstep engine.py:
from hitchstory import BaseEngine class Engine(BaseEngine): def create_file(self, file_name=&amp;#34;step1.txt&amp;#34;, content=&amp;#34;example&amp;#34;): with open(file_name, &amp;#39;w&amp;#39;) as handle: handle.write(content) def on_success(self): print(&amp;#34;splines reticulated&amp;#34;) with open(&amp;#34;ranstory.txt&amp;#34;, &amp;#39;w&amp;#39;) as handle: handle.write(self.story.name)from hitchstory import StoryCollection from pathquery import pathquery from engine import EngineStoryCollection(pathquery(&amp;#34;.&amp;#34;).ext(&amp;#34;story&amp;#34;), Engine()).named(&amp;#34;Create files&amp;#34;).play() Will output:
RUNNING Create files in /path/to/example.story ... splines reticulated SUCCESS in 0.</description>
    </item>
    
    <item>
      <title>Screenplay Principle</title>
      <link>https://hitchdev.com/hitchstory/approach/screenplay-principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/screenplay-principle/</guid>
      <description>You don&amp;rsquo;t tell your audience your story, you show them. You must learn to write a screenplay visually. Write what they will see and what they will hear.
 - http://www.screenwriting.info  An iron rule of screenplay writing is that you do not write what a character thinks. You must demonstrate via their actions and words what they think.
This parallels a similar problem with software specification:
 Overspecification - where a spec defines how a problem is to be achieved, rather than what problem is to be achieved.</description>
    </item>
    
    <item>
      <title>Set up with HitchKey</title>
      <link>https://hitchdev.com/hitchstory/setup-with-hitchkey/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/setup-with-hitchkey/</guid>
      <description>You can quickstart hitchstory with hitchkey by installing the hitchkey bootstrapper with pipsi:
pipsi install hitchkey Or, if you prefer to not use pipsi, this is also safe and won&amp;rsquo;t mess with any system dependencies:
sudo pip install hitchkey In your project, create a &amp;ldquo;hitch&amp;rdquo; directory and drop the following files in it:
mystory.story, containing:
Myfirststory:steps:-Dosomething engine.py, containing:
from hitchstory import BaseEngine class Engine(BaseEngine): def __init__(self, paths): self.path = paths def set_up(self): pass def do_something(self): pass  key.</description>
    </item>
    
    <item>
      <title>Shortcut lookup for story names</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/shortcut-lookup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/shortcut-lookup/</guid>
      <description>Hunting for and specifying particular story to run can be a pain.
Using the &amp;lsquo;shortcut&amp;rsquo; function you can select a specific story to run just by specifying one or more key words that appear in the story title. The case is ignored, as are special characters.
If you specify key words that match no stories or more than one story, an error is raised.
example1.story:
Createfile:steps:-CreatefileCreatefileagain:steps:-Createfile example2.story:
Createfiles:steps:-Createfilefrom hitchstory import StoryCollection, BaseEngine from ensure import Ensure from pathquery import pathquery class Engine(BaseEngine): def create_file(self, filename=&amp;#34;step1.</description>
    </item>
    
    <item>
      <title>Special exception named failure</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/special-failure-exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/special-failure-exception/</guid>
      <description>If you want to indicate a test failure, raise the &amp;ldquo;Failure&amp;rdquo; exception.
This is by default an expected exception, so no stack trace will be printed if it is raised.
example.story:
Failingstory:steps:-Raisespecialfailureexception-Stepthatwillnotrun-Stepthatwillnotrun engine.py:
from hitchstory import BaseEngine, no_stacktrace_for, Failure from code_that_does_things import raise_example_exception, output, ExampleException class Engine(BaseEngine): def passing_step(self): pass def failing_step(self): raise_example_exception(&amp;#34;Towel not located&amp;#34;) @no_stacktrace_for(ExampleException) def failing_step_without_stacktrace(self): raise_example_exception(&amp;#34;Expected exception&amp;#34;) def raise_special_failure_exception(self): raise Failure(&amp;#34;Special failure exception - no stacktrace printed!&amp;#34;) def step_that_will_not_run(self): pass def on_failure(self, result): pass def not_executed_step(self): passfrom hitchstory import StoryCollection from engine import Engine from pathquery import pathquery story_collection = StoryCollection(pathquery(&amp;#34;.</description>
    </item>
    
    <item>
      <title>Story that rewrites itself</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/rewrite-story/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/rewrite-story/</guid>
      <description>Hitch stories can be partially rewritten when the code is changed when a step involves verifying a block of text.
It is a time saver when you only want to make modifications to messages output by a program and ensure that those modifications are verified.
Instead of manually constructing the exact output you are expecting you can simply visually inspect the output to verify that it is the desired output.</description>
    </item>
    
    <item>
      <title>Story with parameters</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/parameterized-stories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/parameterized-stories/</guid>
      <description>Parameterized stories are used to describe stories which are essentially the same except for one or more variables which can vary.
A common example is a story for a user to log in with a browser which may be done with a number of different browsers.
Parameters can be used in preconditions and in steps by surrounding the parameter name with (( brackets )).
example.story:
Clickmagicbutton:with:browser:name:firefoxversion:37given:browser:((browser))steps:-Clickonbutton-Savescreenshot:forbrowser:((browser))variations:withchrome:with:browser:name:chromeversion:153 engine.py:
from hitchstory import BaseEngine, GivenDefinition, GivenProperty, validate from strictyaml import Map, Seq, Int, Str, Optional from code_that_does_things import * class Engine(BaseEngine): given_definition=GivenDefinition( browser=GivenProperty( schema=Map({&amp;#34;name&amp;#34;: Str(), &amp;#34;version&amp;#34;: Int()}), ), ) def set_up(self): print(self.</description>
    </item>
    
    <item>
      <title>Strong typing</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/strong-typing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/strong-typing/</guid>
      <description>By default all specified given properties and step arguments accept any kind of YAML which will always be parsed to a string or a nested combination of lists, dicts and strings.
In order to restrict what kind of YAML is allowed and/or to parse strings as something else (e.g. integers), you can use the validator decorator on step methods or the schema parameter on the GivenProperty object.
The &amp;lsquo;mini-schemas&amp;rsquo; you feed these objects should be standard StrictYAML validator objects.</description>
    </item>
    
    <item>
      <title>Triality</title>
      <link>https://hitchdev.com/hitchstory/approach/triality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/triality/</guid>
      <description>All great software needs three things:
 Specification Tests Documentation  Each of these things is intimately tied. Every new feature must be specified, tested and documented.
If each of these things are done separately, it violates another core principle of software: DRY.
However, if each of these things are intrinsically the same - the specification IS the test which IS the documentation, then there is no need to duplicate effort, code and writing.</description>
    </item>
    
    <item>
      <title>Two Unit Tests, Zero Integration Tests</title>
      <link>https://hitchdev.com/hitchstory/why/2-unit-tests-0-integration-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/2-unit-tests-0-integration-tests/</guid>
      <description>Hitchstory was inspired by the realization that integration tests are almost always more effective than unit tests.</description>
    </item>
    
    <item>
      <title>Variations</title>
      <link>https://hitchdev.com/hitchstory/using/alpha/variations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/using/alpha/variations/</guid>
      <description>Some stories are very similar except for a few changed items. You can create substories within the same story in order to enumerate all of the possible permutations.
This works in the same way as inheritance.
example.story:
Createfiles:given:content:doghierarchicalcontent:x:1y:-42steps:-Dothingwithprecondition-Dootherthing:dog-Doyetanotherthing-Doafourththing:animals:pondanimal:frogvariations:cat:given:content:catfrom hitchstory import StoryCollection, BaseEngine, GivenDefinition, GivenProperty, validate from strictyaml import Map, Seq, Int, Str, Optional from pathquery import pathquery from ensure import Ensure class Engine(BaseEngine): given_definition=GivenDefinition( content=GivenProperty(schema=Str()), hierarchical_content=GivenProperty( schema=Map({&amp;#34;x&amp;#34;: Int(), &amp;#34;y&amp;#34;: Seq(Str())}) ), ) def do_other_thing(self, parameter): assert type(parameter) is str print(parameter) def do_thing_with_precondition(self): assert type(self.</description>
    </item>
    
    <item>
      <title>What is the difference betweeen a test and a story?</title>
      <link>https://hitchdev.com/hitchstory/approach/test-or-story/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/approach/test-or-story/</guid>
      <description>While a test is turing complete code that tests behavior, a story is turing-incomplete code which defines behavior.
A test is simply code that is executed and either raises an exception indicating a failure or passes.
A story must be played using an execution engine.
A story can be translated into readable documentation, often with the aid of artefacts created when running the story (e.g. screenshots).</description>
    </item>
    
    <item>
      <title>Why does HitchStory use StrictYAML?</title>
      <link>https://hitchdev.com/hitchstory/why/strictyaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/strictyaml/</guid>
      <description>HitchStory stories are written using YAML because it:
 Has a clear and obvious layout and relationships driven by its indentation structure. Has minimal syntactic noise. Displays complex hierarchical data cleanly. Displays multiline strings cleanly.  These features make it a particularly good fit for writing declarative stories with, since they often require a lot of hierarchical data and multiline strings to display clearly.
Its relative existing popularity also means that it is somewhat familiar to a lot of people and there is a lot of existing tooling which can be used (e.</description>
    </item>
    
    <item>
      <title>Why does hitchstory not have an opinion on what counts as interesting to &#34;the business&#34;?</title>
      <link>https://hitchdev.com/hitchstory/why/interesting-to-the-business/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why/interesting-to-the-business/</guid>
      <description>When Cucumber first gained some popularity, there was something of a backlash from the original developers that the users &amp;ldquo;weren&amp;rsquo;t using it correctly&amp;rdquo;:
The specific complaint was that it was being used as an integration testing framework rather than a tool for &amp;ldquo;communicating with the business&amp;rdquo; and that everything except the high level &amp;ldquo;business requirements&amp;rdquo; should be abstracted away.
Hitchstory takes a different approach and recommends the screenplay principle instead, for the following reasons:</description>
    </item>
    
    <item>
      <title>Why not use Behave, Lettuce or Cucumber (Gherkin)?</title>
      <link>https://hitchdev.com/hitchstory/why-not/gherkin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why-not/gherkin/</guid>
      <description>HitchStory and Gherkin are both DSLs for writing user stories that can double as acceptance tests, but they have different philosophies and approach.
Gherkin scenarios emphasize the following values:
 The use of English to facilitate customer collaboration. Showing information that is &amp;ldquo;interesting to the business&amp;rdquo;.  Here are some examples.
From the Cucumber website:
Scenario: Buy last coffee Given there are 1 coffees left in the machine And I have deposited 1$ When I press the coffee button Then I should be served a coffee Hitch scenarios, by contrast, emphasizes the following values:</description>
    </item>
    
    <item>
      <title>Why not use the Robot Framework?</title>
      <link>https://hitchdev.com/hitchstory/why-not/robot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why-not/robot/</guid>
      <description>HitchDev was, in a sense, inspired by the robot framework. I used it many years ago and became incredibly frustrated using it for debugging.
The last straw was trying to debug a robot test failure and discovering that the step that the test failed on was not displayed to the end user. It turned out that the maintainers had reasons for doing this, but they were bad reasons.
I eventually dumped it and used python&amp;rsquo;s built in unit testing framework, which is unsuitable for many other reasons.</description>
    </item>
    
    <item>
      <title>Why use hitchstory instead of a unit testing framework?</title>
      <link>https://hitchdev.com/hitchstory/why-not/unit-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/hitchstory/why-not/unit-test/</guid>
      <description>This is not an argument against the following:
 Testing in general Test driven development Low level testing (of classes and methods or otherwise) Property based testing (e.g. hypothesis). Mocking Doctests  All have their place.
This simply about the use of unit testing frameworks - py.test, nose, unittest2, jUnit, etc. for low level testing, integration testing and end to end testing.
There are, broadly speaking, two types of code - algorithmic code and integration code.</description>
    </item>
    
  </channel>
</rss>
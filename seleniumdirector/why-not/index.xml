<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Why not X? on HitchDev</title>
    <link>https://hitchdev.com/seleniumdirector/why-not/</link>
    <description>Recent content in Why not X? on HitchDev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://hitchdev.com/seleniumdirector/why-not/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why not use Capybara-Py or Splinter?</title>
      <link>https://hitchdev.com/seleniumdirector/why-not/capybara-py-or-splinter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/why-not/capybara-py-or-splinter/</guid>
      <description>Capybara-Py (and Capybara) and Splinter are both wrappers around selenium which can be used to write acceptance tests.
Similar to seleniumdirector, both wrap around a selenium Webdriver object and provide a nicer API on it. They by and large provide all the same functionality that selenium does.
Seleniumdirector is different because separates selector management from actions on elements. Selectors are specified in a YAML file while actions are executed with code.</description>
    </item>
    
    <item>
      <title>Why not use Robot SeleniumLibrary?</title>
      <link>https://hitchdev.com/seleniumdirector/why-not/robot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/why-not/robot/</guid>
      <description>Robot&amp;rsquo;s SeleniumLibrary is a layer around selenium designed to integrate it with the Robot framework. It is designed to create test cases like this:
*** Settings *** Library SeleniumLibrary *** Test Cases *** The user can search for flights [Tags]	search_flights Open browser http://blazedemo.com/ Chrome Select From List By Value xpath://select[@name=&#39;fromPort&#39;] Paris Select From List by Value xpath://select[@name=&#39;toPort&#39;] London Click Button css:input[type=&#39;submit&#39;] @{flights}= Get WebElements css:table[class=&#39;table&#39;]&amp;gt;tbody tr Should Not Be Empty ${flights} Close All Browsers  Example taken from https://www.</description>
    </item>
    
    <item>
      <title>Why not use the page object pattern?</title>
      <link>https://hitchdev.com/seleniumdirector/why-not/page-object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hitchdev.com/seleniumdirector/why-not/page-object/</guid>
      <description>The page object pattern is a design pattern for creating a code API abstraction around web pages to simplify their usage in GUI tests.
SeleniumDirector uses a &amp;ldquo;selector configuration pattern&amp;rdquo; where element selectors (id, css, xpath, etc.) are grabbed from a configuration file while the actual actions on HTML elements are not abstracted at all.
The idea of the page object pattern is is to enact a separation of concerns between the code that interacts directly with HTML and the code which interacts with the web application.</description>
    </item>
    
  </channel>
</rss>